<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>urn:2022-03-01T01:00:57.496Z</id>
    <title>osmos::feed</title>
    <updated>2022-03-01T01:00:57.496Z</updated>
    <generator>osmosfeed 1.14.4</generator>
    <link rel="alternate" href="index.html"/>
    <entry>
        <title type="html"><![CDATA[周刊（第7期）：一个C系程序员的Rust初体验]]></title>
        <id>https://www.codedump.info/post/20220227-weekly-7/</id>
        <link href="https://www.codedump.info/post/20220227-weekly-7/"/>
        <updated>2022-02-27T03:25:33.000Z</updated>
        <summary type="html"><![CDATA[引言：在工作里使用Rust已经有两个多月的时间了，谈谈我做为一名多年的C系（C、C++）程序员，对Rust的初体验。
一个C系程序员的Rust初体验
最近由于工作的原因，使用上了Rust语言，在此之前我有多年的C、C++编码经验（以下将C、C++简称C系语言）。
使用C系语言编码时，最经常面对的问题就是内存问题，诸如：
野指针（Wild Pointe）：使用了不可知的指针变量，如已经被释放、未初始化、随机，等等。
内存地址由于访问越界等原因被覆盖（overflow），这不但是可能出错的问题，还有可能成为程序的内存漏洞被利用。
内存分配后未回收。
连Chrome的报告都指出，Chrome中大约70%的安全漏洞都是内存问题，见：Memory safety。
C系语言发展到今天，已经有不少可以用于内存问题检测的利器了，其中最好用的莫过于AddressSanitizer，它的原理是在编译时给程序加上一些信息，一旦发生内存越界访问、野指针等错误都会自动检测出来。
但是即便有这些工具，内存问题也不好解决，其核心的原因在于：这些问题绝大部分都是运行时（Runtime）问题，即要在程序跑到特定场景的时候才会暴露出来，诸如上面提到的AddressSanitizer就是这样。
都知道解决问题的第一步是能复现问题，而如果一个问题是运行时问题，这就意味着：复现问题可能会是一件很麻烦的事情，有时候还可能到生产环境去复现。
以我之前经历的一个Bug来看这类工作的复杂度，见线上存储服务崩溃问题分析记录 - codedump的网络日志，这是一个很典型的发生在生产环境上由于内存错误导致的崩溃问题：
不好复现，因为跟特定的请求相关，还跟线程的调度有关；
本质是由于使用了被释放的内存导致的错误。
这个线上问题，记得当时花了一周时间来复现问题解决。
换言之，如果一个问题要等到运行时才能发现，那么可以预见的是：一旦…]]></summary>
        <author>
            <name>codedump的网络日志 on codedump的网络日志</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[profiling & Flame Graphs]]></title>
        <id>https://yeshan333.github.io/2022/02/26/profiling-flame-graph/</id>
        <link href="https://yeshan333.github.io/2022/02/26/profiling-flame-graph/"/>
        <updated>2022-02-26T22:54:38.000Z</updated>
        <summary type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"]]></summary>
        <author>
            <name>ShanSan</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021 年年鉴]]></title>
        <id>https://www.kawabangga.com/?p=4626</id>
        <link href="https://www.kawabangga.com/posts/4626"/>
        <updated>2022-02-25T16:24:42.000Z</updated>
        <summary type="html"><![CDATA[今年没有在跨年的时候及时写完年终总结，是因为那天还在西安隔离。2021 年一整年依然是疫情肆虐，下半年在新加坡 […]
Continue reading...
The post 2021 年年鉴 first appeared on 卡瓦邦噶！.

相关文章:

我在新加坡一个月的生活费明细
为什么 Cloudflare 提供免费的服务？
Build 一个最小的 Redis Docker Image
《Prometheus Up & Running》阅读
使用 mtr 检查网络问题，以及注意事项]]></summary>
        <author>
            <name>laixintao</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S 生态周报| containerd v1.6 正式发布，带来众多新特性]]></title>
        <id>https://moelove.info/2022/02/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.6-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/</id>
        <link href="https://moelove.info/2022/02/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.6-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/"/>
        <updated>2022-02-20T12:55:03.000Z</updated>
        <summary type="html"><![CDATA[「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
containerd v1.6.0 正式发布
containerd v1.6 在本周也正式发布了，这是 containerd 的第 7 个大版本。距离上一个大的正式版 v1.5.0 已经过了将近 9 个月的时间（v1.5.0 是 2021 年 5 月发布的），关于 containerd v1.5.0 的主要变更，可参考我去年写的 K8S 生态周报| containerd v1.5.0-rc.0 发布。我们一起来看看 containerd v1.6.0 中有哪些值得关注的变更吧！
Runtime
#5744 在 containerd 的 metrics 接口中增加了 runtime 的 label;
#6375 将 runc 的依赖升级到了 v1.1.0 版本；
#5871 增加了 shim plugin 的支持，重构了 shim v2 来加载和注册 plugin;
CRI
#5619 当前会同时支持 CRI v1 和 v1alpha2 ；
#6113 实现了新的 Kubernetes CRI pod sandbox stats API，这其实是为了遵守 Kubernetes 中 CRI 的变更。其根本原因实际上是在 Kubernetes 中希望能够增强 CRI 的能力，减少对 cAdvisor 的依赖。更深层次的则是由于 cAdvisor 仅支持 Linux 容器，和一般的容器运行时，无法支持类似 Kata Containers 这类 VM 运行时，以及不支持 Windows 容器。由此其实我们也可以看出来 Kubernetes & containerd 的一些目标，做的更通用，更标准化；
#6111 添加了 sandbox 和 container 延迟…]]></summary>
        <author>
            <name>zhangjintao9020@gmail.com (张晋涛)</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[周刊（第6期）：《sqlite 3.36 btree实现解析》番外篇]]></title>
        <id>https://www.codedump.info/post/20220220-weekly-6/</id>
        <link href="https://www.codedump.info/post/20220220-weekly-6/"/>
        <updated>2022-02-20T02:53:41.000Z</updated>
        <summary type="html"><![CDATA[引言：从2021年9月份开始要探索生产级btree存储引擎的实现，到2022年2月整理完毕发布《sqlite 3.36 btree实现解析》的系列文章，我花费了小半年的时间，本期会聊聊整个过程下来我的一些想法。
《sqlite 3.36 btree实现解析》番外篇
时间回到2021年9月份。彼时，因为工作的关系，要研究一下生产级btree存储引擎的实现，在此之前我大体对btree、b+tree的数据结构和算法有个了解，见：
B树、B+树索引算法原理（上） - codedump的网络日志
B树、B+树索引算法原理（下） - codedump的网络日志
但是，一个生产级的产品，对比教科书的示范型代码，还是有很大的区别的，具体来说，我当时不明白以下这些生产级存储引擎的问题如何解决：
如何存储变长的数据？
如何存储数据大小超过一个物理页面的数据？
如何利用被回收的空间？
如何处理崩溃恢复？
读写并发如何处理？
…
为了解答这些疑问，先后去翻阅InnodDB、WiredTiger、sqlite的文档，但是这些项目代码量都太大了，以我当时的程度，无法马上找到很具体的解答。
事情的突破在从网上查找文章时看到的这一篇文章：How Database B-Tree Indexing Works - DZone Database，这是一篇解释btree工作原理的文章，这篇文章同时还列出了一个项目：madushadhanushka/simple-sqlite: Code reading for sqlite backend，这个项目的作者，将sqlite2.5版本中btree的实现，单独抽取出来形成了一个独立的KV库，可以编译通过使用。
看到这个项目的时候，我的感觉就是如获至宝，因为虽然只有几千行的代码量，但是解答了很多上面提到的疑问，“麻雀虽小五脏俱全”，我花了几天的时间整体阅读了解了原理，这个…]]></summary>
        <author>
            <name>codedump的网络日志 on codedump的网络日志</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S 生态周报| Istio 即将发布重大安全更新，多个版本受影响]]></title>
        <id>https://moelove.info/2022/02/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%8D%B3%E5%B0%86%E5%8F%91%E5%B8%83%E9%87%8D%E5%A4%A7%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%97%E5%BD%B1%E5%93%8D/</id>
        <link href="https://moelove.info/2022/02/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%8D%B3%E5%B0%86%E5%8F%91%E5%B8%83%E9%87%8D%E5%A4%A7%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%97%E5%BD%B1%E5%93%8D/"/>
        <updated>2022-02-15T16:14:36.000Z</updated>
        <summary type="html"><![CDATA[「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
Istio 即将发布重大安全更新，多个版本受影响
Istio 产品安全工作组近期发现 Istio 中存在一些安全漏洞，其中 最高级别的漏洞被评级为高严重性。
鉴于当前 Istio 的漏洞披露政策，所以目前我们不会透露具体的漏洞细节。
在一周后的 2 月 22 日，将会发布 Istio v1.11.7、v1.12.3 和 v1.13.1 版本修正这些安全漏洞。届时会再更新漏洞的详细内容。
请参考官方通告
此外，本周 Istio 也发布了 v1.13.0 正式版， 在 v1.13.1 版本发布前，我不建议大家将自己所用的 Istio 升级到 v1.13.0 。
虽然不建议现在升级，但我们也可以关注下 v1.13.0 带来的一些值得关注的变更：
v1.13.0 版本中为东西向流量提供了基于主机名的多网络网关支持。主机名可以在控制面中被解析，解析记录可被用作 endpoint。
如果你不需要这个行为，或者想要恢复到之前版本中的默认行为，可以为 istiod 添加 RESOLVE_HOSTNAME_GATEWAYS=false 的配置。
此外，它还支持重写 gRPC 探针，以及通过 proxyMetadata 提供了在 Envoy 工作线程间的重平衡，并且通过学习 Kubernetes 的探测
行为，改善了 istio-agent 健康检查的探测，这样它就不会再重用连接了。请参考 #36390 。
同时我们会发现在这个版本中它对 Telemetry API 的支持增加了不少，尤其是它为 access log 支持了
Common Expression Language (CEL) filter 。如果你觉得对 CEL 有些陌生，那么你可以看下我之前的文章 《K8S…]]></summary>
        <author>
            <name>zhangjintao9020@gmail.com (张晋涛)</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.14.4]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.4</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.4"/>
        <updated>2022-02-14T06:58:28.000Z</updated>
        <summary type="html"><![CDATA[Fixed: Several style issues]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.14.3]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.3</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.3"/>
        <updated>2022-02-14T06:29:16.000Z</updated>
        <summary type="html"><![CDATA[style tweak]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.14.2]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.2</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.2"/>
        <updated>2022-02-14T05:53:33.000Z</updated>
        <summary type="html"><![CDATA[New: Adjust article grouping based on timezone. You need to add timezone in osmosfeed.yml for accurate grouping. See details in documentation.
New: Card title now toggles card content
New: all toggles on the UI are persisted with local storage. You can use it to track read/unread status within a single browser.
New: Build timestamp now links to the GitHub Action run
Changed: Sources are sorted based on publish time rather than alphabetical order
Changed: Style adjusted for easier reading
Fixed: Horizontal overflow on Safari
Fixed: HTML syntax error in default template]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.14.1]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.1</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.1"/>
        <updated>2022-02-14T05:26:23.000Z</updated>
        <summary type="html"><![CDATA[git typo in gh run url]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.14.0: V1.14.0 (#79)]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.0</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.0"/>
        <updated>2022-02-14T05:13:00.000Z</updated>
        <summary type="html"><![CDATA[New: Adjust article grouping based on timezone. You need to add timezone in osmosfeed.yml for accurate grouping. See details in documentation.
New: Card title now toggles card content
New: all toggles on the UI are persisted with local storage. You can use it to track read/unread status within a single browser.
New: Build timestamp now links to the GitHub Action run
Changed: Sources are sorted based on publish time rather than alphabetical order
Changed: Style adjusted for easier reading
Fixed: Horizontal overflow on Safari
Fixed: HTML syntax error in default template]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.13.0]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.13.0</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.13.0"/>
        <updated>2022-02-13T05:05:17.000Z</updated>
        <summary type="html"><![CDATA[New: Thumbnail image display for each article
New: Improved color, spacing, and typography for easier reading
New: Click the date to toggle all accordions on that day. Ctrl + Click to toggle all accordions on the entire site.
Changed: All sections are expanded by default
Changed: Switched to vitest for easier testing
Fixed: Long string (e.g. URL) caused horizontal overflow
Thank you: @naari3, @tianheg]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[“一把梭：REST API 全用 POST”]]></title>
        <id>https://coolshell.cn/?p=22173</id>
        <link href="https://coolshell.cn/articles/22173.html"/>
        <updated>2022-02-13T04:28:47.000Z</updated>
        <summary type="html"><![CDATA[写这篇文章的原因主要还是因为V2EX上的这个贴子，这个贴子中说—— “对接同事的接口，他定义的所有接口都是 post 请求，理由是 https 用 post 更...
 Read More  Read More
“一把梭：REST API 全用 POST” first appeared on 酷 壳 - CoolShell.]]></summary>
        <author>
            <name>陈皓</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[v1.12.1]]></title>
        <id>https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.1</id>
        <link href="https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.1"/>
        <updated>2022-02-12T17:46:42.000Z</updated>
        <summary type="html"><![CDATA[Fixed: Future articles appeared in the feed
Fxied: Security vulnerability from axios
Thank you: @naari3]]></summary>
        <author>
            <name>Release notes from osmosfeed</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[谈谈公司对员工的监控]]></title>
        <id>https://coolshell.cn/?p=22157</id>
        <link href="https://coolshell.cn/articles/22157.html"/>
        <updated>2022-02-12T07:50:06.000Z</updated>
        <summary type="html"><![CDATA[今天看到微博上有一个热点事件， 是一个关于某公司做的一个监控员工离职倾向的软件，从截图中可以看到员工访问招聘网站的次数，还有投递的简历以及搜索的关建词等等信息，...
 Read More  Read More
谈谈公司对员工的监控 first appeared on 酷 壳 - CoolShell.]]></summary>
        <author>
            <name>陈皓</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[周刊（第5期）：从存储模型聊一聊时序数据库的应用场景]]></title>
        <id>https://www.codedump.info/post/20220211-weekly-5/</id>
        <link href="https://www.codedump.info/post/20220211-weekly-5/"/>
        <updated>2022-02-11T14:27:57.000Z</updated>
        <summary type="html"><![CDATA[引言：本期介绍时序数据库的存储模型，只有理解了时序数据的存储模型，才能更好的了解时序数据库的优缺点以及其适用场景。
从存储模型聊一聊时序数据库的应用场景
想写本文，是因为看到了知乎上的一篇文章：投资数据库领域：2021年总结（NoSQL、图、时序） - 知乎，里面谈到了时序数据库：
但缺陷是实际的市场空间较小。跟通用型数据库，尤其是OLAP数据库相比，时序数据库最大的差异点在于对于时间维度建立了独特的索引与优化，而其他所谓schemaless等特性在OLAP数据库上都能做到，不存在技术障碍。这也就是为什么其实在公司做时序场景的数据库选型的时候会直接将时序数据库与一些OLAP数据库（比如ClickHouse）做比较。如果要把时序数据库往更宽的场景发展，那就是想好如何与那么多的通用型数据库做竞争了。
由于之前有过短暂一段时间的时序数据库从业经历，所以想从我的理解聊聊时序数据库的应用场景。
要了解应用场景，需要首先对时序数据库的存储模型有个大概的了解，在下文中我尽量不涉及到太艰深的技术术语来描述我的理解。由于我从业时序数据库的时间并不长，所以有可能理解会有偏差。
何谓“时序数据（time-series data）”？就我个人粗浅的理解，就是任何一定会带上时间戳（timestamp）维度的数据。日常生活里，在微博、微信等社交媒体的发现就可以理解时序数据，因为它们肯定都有一个发言时间，所以有时候会把个人看到的微博等称为“时间线（timeline）”。对应到工业领域，比如一个电表每小时上报的用电量也是时序数据，比如服务器监控时每隔15分钟采集的性能数据也是时序数据。
由于时序数据天然有“时间“这个维度，为了更好的优化其写入性能，通常专门存储时序数据的存储引擎会按照时间分块、按列来存储数据，如下图：



上图中，演示用的数据格式有三列：
时间戳。
A指标。
B指标。
通常，时序数据库存…]]></summary>
        <author>
            <name>codedump的网络日志 on codedump的网络日志</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[周刊（第4期）：为什么我还在看中国足球]]></title>
        <id>https://www.codedump.info/post/20220204-weekly-4/</id>
        <link href="https://www.codedump.info/post/20220204-weekly-4/"/>
        <updated>2022-02-04T13:55:23.000Z</updated>
        <summary type="html"><![CDATA[引言：虎年大年初一的晚上，一场脆败发生在世界杯亚洲区预选赛中国客场对越南队的比赛上。如今，“你居然还在看中国男足”，仿佛已成一句骂人的质问。本期从我角度来谈谈，我眼中的中国足球，以及说说我为什么还一直在关注这个领域。
我为什么还在看中国足球
我从94年开始看球，中国足球绝大部分的重要比赛都看了：94年亚运会决赛输给乌兹别克斯坦、97年大连金州被伊朗逆转、2002年世界杯出线…太多了，数不过来，算是从我开始看球之后就一直有关注中国足球。
在看国足比赛二十多年之后，慢慢地从一个参与者、评论者的角色，切换到了近似于第三方视角的观察者角色。切换到这个视角之后，让我能从里面各种情绪里抽离出来，当然高兴的时候也会像个普通球迷那样欢乐，比如2017年世界杯预选赛击败韩国这样的比赛。
我国虽然在奥运会上取得了看似很好的成绩，金牌数总是保持前列，但是有一说一，并不算是体育大国，更别提强国了。
只看我们占优势、能取得好成绩的项目，大多有这样的特点：小众、冷门，这样的特点直接导致这样的项目，实际是商业化程度很低的领域。这样的领域，国外参与的人不会太多，也因此可以继续沿用以前我们擅长的打法：集中力量办大事，换到体育这个领域，就是所谓的“举国体制”。
这样做的好处是，能用较少的资源拿到不错的效果，因为大部分人只关注金银牌这些数字，并不关心你怎么拿到的。这个策略，用知乎上一个回答的话来说叫“田忌赛马”，见：为什么中国的其他运动项目那么强，到了男足这里就不行呢？
在商业化、职业化很好的体育项目，比如足球、篮球、网球等等领域，我们的成绩就不这么好了，李娜、姚明、刘翔是少数在这些领域拿得出手的世界级运动员。（后面会专门谈谈女足）
一言以蔽之：举国体制从目前的成绩来看，并不适合职业化、商业化很好的体育项目。
“足球是体育工业化的集大成者”（见(为什么整个中国都知道中国足球的问题，为什么还是没有办法解决？ - …]]></summary>
        <author>
            <name>codedump的网络日志 on codedump的网络日志</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[sqlite3.36版本 btree实现（五）- Btree的实现]]></title>
        <id>https://www.codedump.info/post/20220201-sqlite-btree-5-btree/</id>
        <link href="https://www.codedump.info/post/20220201-sqlite-btree-5-btree/"/>
        <updated>2022-02-01T07:55:40.000Z</updated>
        <summary type="html"><![CDATA[《sqlite3.36版本 btree实现》系列文章：
sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志
sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志
sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志
sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志
sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志
sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志
概述
前面的内容里，详细介绍了页面管理器部分的内容，回顾一下页面管理器和Btree模块的分工：
页面管理器：提供页面级别的物理管理，如缓存、读取、写入、页面备份等。
Btree：根据btree数据结构提供页面在逻辑上的组织，以及单个页面内的划分。
还记得最开始，研究生产级别btree实现时的几个疑问：
数据库教科书中，演示btree算法时，使用的都是定长的简单数据。实际应用中，存储的数据都是变长的，那么应该如何存储变长的数据呢？
如果一行数据的大小，超过了一个物理页面的大小，又该如何处理？
删除一行数据之后，它留下的空间如何回收利用？而回收利用时，不可避免的会出现碎片的问题，比如原先10字节的数据被回收，用来存储9字节的数据，多出来的1字节数据就被浪费了，碎片问题应该如何解决？
这些问题，都与“一个物理页面内数据如何组织”这个核心问题息息相关，带着这些问题展开btree实现的讨论。
在下文中，不会讨论btree算法的细节，这部分不熟悉的，可以回看之前的文章或者教科书：
B树、B+树索引算法原理（上） - codedump的网络日志
B树、…]]></summary>
        <author>
            <name>codedump的网络日志 on codedump的网络日志</name>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[状态机的一点儿事（fsm-smr-dfsm）]]></title>
        <id>https://yeshan333.github.io/2022/01/31/fsm-smr-dfsm/</id>
        <link href="https://yeshan333.github.io/2022/01/31/fsm-smr-dfsm/"/>
        <updated>2022-01-31T17:32:51.000Z</updated>
        <summary type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"]]></summary>
        <author>
            <name>ShanSan</name>
        </author>
    </entry>
</feed>