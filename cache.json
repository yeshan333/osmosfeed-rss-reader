{
  "sources": [
    {
      "title": "Release notes from osmosfeed",
      "feedUrl": "https://github.com/osmoscraft/osmosfeed/releases.atom",
      "siteUrl": "https://github.com/osmoscraft/osmosfeed/releases",
      "articles": []
    },
    {
      "title": "ShanSan",
      "feedUrl": "https://shansan.top/rss2",
      "siteUrl": "https://yeshan333.github.io/",
      "articles": [
        {
          "id": "https://yeshan333.github.io/2021/11/27/loopback-addr/",
          "author": null,
          "description": "心血来潮，小水一篇！\n回环地址（loopback address）\n\nloopback 在维基百科上有一段这样的解释：Loopback (also written loop-back) is the routing of electronic signals or digital data streams back to their source without intentional processing or modification. It is primarily a means of testing the communications infrastructure.\n通熟的说就是将由“源”发送出去的数据路由回“源”。",
          "link": "https://yeshan333.github.io/2021/11/27/loopback-addr/",
          "publishedOn": "2021-11-27T11:41:50.000Z",
          "wordCount": 330,
          "title": "回环地址的一点儿破事"
        },
        {
          "id": "https://yeshan333.github.io/2021/11/14/back-to-october/",
          "author": null,
          "description": "前言\n不知不觉，离开校园将近四个月了，正式工作（摸🐟~）也差不多四个多月了，最近经历了很多事，头发也掉了不少😂",
          "link": "https://yeshan333.github.io/2021/11/14/back-to-october/",
          "publishedOn": "2021-11-14T10:21:37.000Z",
          "wordCount": 219,
          "title": "回到十月-生活中的一点儿小确幸"
        }
      ]
    },
    {
      "title": "酷 壳 – CoolShell",
      "feedUrl": "https://coolshell.cn/feed",
      "siteUrl": "https://coolshell.cn",
      "articles": [
        {
          "id": "https://coolshell.cn/?p=21649",
          "author": "陈皓",
          "description": "最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains...\n Read More  Read More\n源代码特洛伊木马攻击 first appeared on 酷 壳 - CoolShell.",
          "link": "https://coolshell.cn/articles/21649.html",
          "publishedOn": "2021-11-19T09:02:46.000Z",
          "wordCount": 953,
          "title": "源代码特洛伊木马攻击"
        }
      ]
    },
    {
      "title": "面向信仰编程",
      "feedUrl": "https://draveness.me/feed.xml",
      "siteUrl": "https://draveness.me/",
      "articles": [
        {
          "id": "https://draveness.me//golang-book-release",
          "author": null,
          "description": "",
          "link": "https://draveness.me//golang-book-release",
          "publishedOn": "2021-11-20T00:00:00.000Z",
          "wordCount": 81,
          "title": "《Go 语言设计与实现》纸质书预售了！"
        }
      ]
    },
    {
      "title": "卡瓦邦噶！",
      "feedUrl": "https://www.kawabangga.com/feed",
      "siteUrl": "https://www.kawabangga.com",
      "articles": [
        {
          "id": "https://www.kawabangga.com/?p=4617",
          "author": "laixintao",
          "description": "记录一个今天遇到的小问题。这是继 Debug 一个在 uWSGI 下使用 subprocess 卡住的问题 之 […]\nContinue reading...\nThe post 寻找丢失的信号 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\nuWSGI socket 队列被占满的问题\nDebug 一个在 uWSGI 下使用 subprocess 卡住的问题\n如何杀死一个进程？\nSRE&Devops 每周分享 Issue #3\n我的线程池怎么没了？",
          "link": "https://www.kawabangga.com/posts/4617",
          "publishedOn": "2021-11-26T14:25:38.000Z",
          "wordCount": 949,
          "title": "寻找丢失的信号"
        },
        {
          "id": "https://www.kawabangga.com/?p=4607",
          "author": "laixintao",
          "description": "周末看了一下 coredns 的源代码，目前为止只是差不多搞清楚了这个代码库的逻辑。写篇博客记录一下，如果你也 […]\nContinue reading...\nThe post Coredns 源码阅读（导读） first appeared on 卡瓦邦噶！.\n\n相关文章:\n\nJoin Shopee & Work with Me!\n辅助Django开发的一些隐藏资源（文档）\n一些命令行工具的增强版\n实时上传数据备份文件到S3",
          "link": "https://www.kawabangga.com/posts/4607",
          "publishedOn": "2021-11-14T10:43:09.000Z",
          "wordCount": 556,
          "title": "Coredns 源码阅读（导读）"
        },
        {
          "id": "https://www.kawabangga.com/?p=4481",
          "author": "laixintao",
          "description": "有很多人问过我想了解一下 SRE 这个岗位，这是个很大的话题，在这篇博客中把想到的一些介绍一下吧。 SRE 到 […]\nContinue reading...\nThe post SRE 的工作介绍 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\n构建大型Cron系统的思考\n博客维护：速度优化，嵌入instagram\nPython正则表达式解惑\n申请友链\nDB资料集",
          "link": "https://www.kawabangga.com/posts/4481",
          "publishedOn": "2021-11-06T15:23:03.000Z",
          "wordCount": 895,
          "title": "SRE 的工作介绍"
        }
      ]
    },
    {
      "title": "MoeLove",
      "feedUrl": "https://moelove.info/index.xml",
      "siteUrl": "https://moelove.info/",
      "articles": [
        {
          "id": "https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\nPrometheus 几乎已经成为了云原生时代下监控选型的事实标准，它也是第二个从 CNCF 毕业的项目。\n当前，Prometheus 几乎可以满足各种场景/服务的监控需求。我之前有写过一些文章介绍过 Prometheus 及其生态，本篇我们将聚焦于 Prometheus 最新版本中发布的 Agent 模式，对于与此主题无关的一些概念或者用法，我会粗略带过。\n拉模式（Pull）和 推模式（Push）\n众所周知，Prometheus 是一种拉模式（Pull）的监控系统，这不同于传统的基于推模式（Push）的监控系统。\n什么是拉模式（Pull）呢？\n\n待监控的服务自身或者通过一些 exporter 暴露出来一些 metrics 指标的接口，由 Prometheus 去主动的定时进行抓取/采集，这就是拉模式（Pull）。即由监控系统主动的去拉（Pull）目标的 metrics。\n与之相对应的就是推模式（Push）了。\n\n由应用程序主动将自身的一些 metrics 指标进行上报，监控系统再进行相对应的处理。如果对于某些应用程序的监控想要使用推模式（Push），比如：不易实现 metrics 接口等原因，可以考虑使用 Pushgateway 来完成。\n对于拉模式（Pull）和推模式（Push）到底哪种更好的讨论一直都在继续，有兴趣的小伙伴可以自行搜索下。\n这里主要是聚焦于单个 Prometheus 和应用服务之间交互的手方式。本篇我们从更上层的角度或者全局角度来看看当前 Prometheus 是如何做 HA、 持久化和集群的。\nPrometheus HA/持久化/集群的方案\n在大规模生产环境中使用时，很少有系统中仅有一个单实例 Prometheus 存在的情况出现。无论从高可用、数据持久化还是从为用户提供更易用的全局视图来考虑，运行多个 Prometheus 实…",
          "link": "https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/",
          "publishedOn": "2021-11-27T16:26:44.000Z",
          "wordCount": 684,
          "title": "新功能：Prometheus Agent 模式上手体验"
        },
        {
          "id": "https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n近期 Rust 社区/团队有些变动，所以再一次将 Rust 拉到大多数人眼前。\n我最近看到很多小伙伴说的话：\nRust 还值得学吗？社区是不是不稳定呀\nRust 和 Go 哪个好？\nRust 还值得学吗？\n这些问题如果有人来问我，那我的回答是：\n小孩子才做选择，我都要！\n当然，关于 Rust 和 Go 的问题也不算新，比如之前的一条推文：\n\n我在本篇中就来介绍下如何用 Go 调用 Rust。\n当然，这篇中我基本上不会去比较 Go 和 Rust 的功能，或者这种方式的性能之类的，Just for Fun\nFFI 和 Binding\nFFI (Foreign Function Interface) 翻译过来叫做外部函数接口（为了比较简单，下文中都将使用 FFI 指代）。最早来自于 Common Lisp 的规范，这是在 wiki 上写的，我并没有去考证。\n不过我所使用过的绝大多数语言中都有 FFI 的概念/术语存在，比如：Python、Ruby, Haskell、Go、Rust、LuaJIT 等。\nFFI 的作用简单来说就是允许一种语言去调用另一种语言，有时候我们也会用 Binding 来表示类似的能力。\n在不同的语言中会有不同的实现，比如在 Go 中的 cgo , Python 中的 ctypes ， Haskell 中的 CAPI （之前还有一个 ccall）等。\n我个人感觉 Haskell 中用 FFI 相比其他语言要更简单&方便的多，不过这不是本篇的重点就不展开了。\n在本文中，对于 Go 和 Rust 而言，它们的 FFI 需要与 C 语言对象进行通信，而这部分其实是由操作系统根据 API 中的调用约定来完成的。\n我们来进入正题。\n准备 Rust 示例程序\nRust 的安装和 Cargo 工具的基本使用，这里就不介绍了。大家可以去 Rust 的官网…",
          "link": "https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/",
          "publishedOn": "2021-11-25T19:04:22.000Z",
          "wordCount": 452,
          "title": "用 Go 调用 Rust"
        },
        {
          "id": "https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\nKubernetes 作为云原生的基石，为我们带来了极大的便利性，越来越多的公司也都将 Kubernetes 应用到了生产环境中。然而，在享受其带来的便利性的同时，我们也需要关注其中的一些安全隐患。\n本篇，我将为你重点介绍容器镜像安全相关的内容。\n通常情况下，我们提到容器镜像安全，主要是指以下两个方面：\n镜像自身内容的安全；\n镜像分发过程的安全；\n镜像自身内容的安全\n要聊镜像自身内容的安全，那我们就需要知道镜像到底是什么，以及它其中的内容是什么。\n镜像是什么\n我们以 debian镜像为例，pull 最新的镜像，并将其保存为 tar 文件，之后进行解压：\n➜ ~ mkdir -p debian-image\n➜ ~ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\n647acf3d48c2: Pull complete\nDigest: sha256:e8c184b56a94db0947a9d51ec68f42ef5584442f20547fa3bd8cbd00203b2e7a\nStatus: Downloaded newer image for debian:latest\ndocker.io/library/debian:latest\n➜ ~ docker image save -o debian-image/debian.tar debian\n➜ ~ ls debian-image\ndebian.tar\n➜ ~ tar -C debian-image -xf debian-image/debian.tar\n➜ ~ tree -I debian.tar debian-image\ndebian-image\n├── 827e5611389abf13d…",
          "link": "https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/",
          "publishedOn": "2021-11-23T15:16:42.000Z",
          "wordCount": 536,
          "title": "云原生时代下的容器镜像安全（上）"
        },
        {
          "id": "https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n提到 Shell 大家想必不会太陌生，我们通常认为 Shell 是我们和系统交互的接口，执行命令返回输出，比如 bash 、zsh 等。偶尔也会有人把 Shell 和 Terminal（终端）混淆，但这和本文关系不大，暂且略过。\n作为一名程序员，我们可能天天都会用到 Shell ，偶尔也会把一些命令组织到一起，写个 Shell 脚本之类的，以便提升我们的工作效率。\n然而在看似简单的 Shell 脚本中，可能隐藏着很深的坑。这里我先给出两段简单且相似的 Shell 脚本，大家不妨来看看这两段代码的输出是什么：\n#!/bin/bash\nset -e -u\ni=0\nwhile [ $i -lt 6 ]; do\necho $i\n((i++))\ndone\n\n答案是只会输出一个 0 。\n#!/bin/bash\nset -e -u\nlet i=0\nwhile [ $i -lt 6 ]; do\necho $i\n((i++))\ndone\n\n答案是没有任何输出，直接退出。\n如果你能解释清楚上面两段代码输出结果的话， 那大概你可以跳过这篇文章后续的内容了。\n我先来分解下这段代码中涉及到的主要知识点。\n变量声明\n变量声明有很多种办法， 但是其行为却各有不同。\n我们必须先有个基础认识： Bash 没有类型系统，所有变量都是 string 。 基于这个原因，如果是让变量进行算术运算时，不能像在其他的编程语言中那样直接写算术运算符。这会让 bash 解释为对 string 的操作，而不是对数字的操作。\n直接声明\n(MoeLove)➜ ~ foo=1+1\n(MoeLove)➜ ~ echo $foo\n1+1\n\n直接声明最简单，但正如前面提到的，直接声明会默认当作 string 进行处理，不能在声明时进行算术运算。\ndeclare 声明\n(MoeLove)➜ ~ declare foo…",
          "link": "https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/",
          "publishedOn": "2021-11-21T14:41:02.000Z",
          "wordCount": 734,
          "title": "Shell 脚本避坑指南（一）"
        },
        {
          "id": "https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。\n对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。\n我们先对这两项技术的作用做个概括：\ncgroup 的主要作用：管理资源的分配、限制；\nnamespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；\n本篇，我们重点来聊 cgroup 。\n为什么要关注 cgroup & namespace\n云原生/容器技术的井喷式增长\n自 1979年，Unix 版本7 在开发过程中引入 Chroot Jail 以及 Chroot 系统调用开始，直到 2013 年开源出的 Docker，2014 年开源出来的 Kubernetes，直到现在的云原生生态的火热。 容器技术已经逐步成为主流的基础技术之一。\n在越来越多的公司、个人选择了云服务/容器技术后，资源的分配和隔离，以及安全性变成了人们关注及讨论的热点话题。\n其实容器技术使用起来并不难，但要真正把它用好，大规模的在生产环境中使用， 那我们还是需要掌握其核心的。\n以下是容器技术&云原生生态的大致发展历程：\n\n图 1 ，容器技术发展历程\n从图中，我们可以看到容器技术、云原生生态的发展轨迹。容器技术其实很早就出现了，但为何在 Docker 出现后才开始有了较为显著的发展？早期的 chroot 、 Linux VServer 又有哪些问题呢？\nChroot 带来的安全性问题\n\n图 2 ，chroot 示例\nChroot 可以将进程及其子进程与操作系统的其余部分隔离开来。但是，对于 root process ，却可以任意退出 chroot。\npackage main\nimport (\n\"log\"\n\"os\"\n\"sy…",
          "link": "https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/",
          "publishedOn": "2021-11-17T15:16:42.000Z",
          "wordCount": 822,
          "title": "一篇搞懂容器技术的基石： cgroup"
        },
        {
          "id": "https://moelove.info/2021/11/03/OCI-%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n这篇文章中我将介绍 OCI 及 Docker 镜像相关的内容，欢迎留言讨论。\nOCI 的前世今生\n2013 年 3 月 dotCloud 公司在 PyCon 上进行了 Docker 的首次展示，随后宣布开源。自此 Docker 开始被众人知晓，随后掀起了一股容器化的热潮。\n在 2014 年 6 月 Docker 1.0 正式发布，有近 460 位贡献者和超过 8700 次提交，这也标志着 Docker 达到了生产可用的状态。\n在当时，提到容器化第一想法就是用 Docker 。而当时 Docker 的实现或者说发展方向主要是由 Docker Inc. 公司控制的，并没有一个统一的工业标准。这对于一些头部公司而言，显然是不能接受的，没有统一的工业标准意味着如果选择了使用 Docker 的容器化技术，便会被 Docker Inc. 公司所绑定；加上随着 Docker 软件的升级，某些功能或者特性必然会进行变动，没人能保证不发生破坏性变更。\n所以，为了推进容器化技术的工业标准化，2015 年 6 月在 DockerCon 上 Linux 基金会与 Google，华为，惠普，IBM，Docker，Red Hat，VMware 等公司共同宣布成立开放容器项目(OCP)，后更名为 OCI。它的主要目标便是 建立容器格式和运行时的工业开放通用标准。\n发展至今， OCI 制定的主要标准有三个分别是 runtime-spec 、image-spec 和 distribution-spec 这三个标准分别定义了容器运行时，容器镜像还有分发的规范，后面会展开介绍。\n为了支持 OCI 容器运行时标准的推进，Docker 公司起草了镜像格式和运行时规范的草案，并将 Docker 项目的相关实现捐献给了 OCI 作为容器运行时的基础实现，现在项目名为 runc 。\n后来 Docke…",
          "link": "https://moelove.info/2021/11/03/OCI-%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/",
          "publishedOn": "2021-11-03T15:16:42.000Z",
          "wordCount": 656,
          "title": "OCI 与下一代镜像构建工具"
        },
        {
          "id": "https://moelove.info/2021/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%A2%9E%E5%BC%BA%E5%AF%B9-OCI-%E7%9A%84%E6%94%AF%E6%8C%81/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。\nDocker v20.10.10 发布\n这个版本是 Docker v20.10 的第 10 个小版本，这个版本中没有什么太特别的共性问题，但是由于 Go 1.16 中 net/http 包对 $HTTP_PROXY 行为的变化，所以当你为 Docker daemon 设置代理的时候，请确认你已经正确的设置了 $HTTP_PROXY 和 $HTTPS_PROXY 等。\n此版本的其他变更，可参考其 ReleaseNote 。至于 Docker v21.x 短时间内还不会发布，不过里面确实增加了一些值得一提的特性，后续新版本快发布前再跟大家分享。\nHelm v3.7 正式发布\nHelm v3.7 是一个特性版本，我们一起来看看有哪些值得关注的变更吧。\n对 OCI Chart 的支持相关的变更\nhelm chart export 已删除\nhelm chart list 已删除\nhelm chart pull 由 helm pull 代替\nhelm chart push 由 helm push 代替\nhelm chart remove 已删除\nhelm chart save 由 helm package 代替\n另外， 如果是通过旧版本创建的 OCI chart 需要使用 Helm v3.7 进行重新打包和上传才能使用。\n一些新特性\n新增 helm uninstall --wait\n新增 helm show crds\nhelm dependency list 新增 --max-col-width 用于设置列宽\nhelm repo add 新增 --password-stdin 用于从 stdin 输入密码\nhelm repo update 可以指定 repo 名称进…",
          "link": "https://moelove.info/2021/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%A2%9E%E5%BC%BA%E5%AF%B9-OCI-%E7%9A%84%E6%94%AF%E6%8C%81/",
          "publishedOn": "2021-10-30T17:15:34.000Z",
          "wordCount": 438,
          "title": "K8S 生态周报| Helm 新版本发布增强对 OCI 的支持"
        }
      ]
    },
    {
      "title": "CJ Ting's Blog",
      "feedUrl": "https://cjting.me/index.xml",
      "siteUrl": "https://cjting.me/",
      "articles": []
    },
    {
      "title": "codedump的网络日志",
      "feedUrl": "https://www.codedump.info/index.xml",
      "siteUrl": "https://www.codedump.info/",
      "articles": []
    }
  ],
  "cliVersion": "1.11.3"
}