{
  "sources": [
    {
      "title": "Release notes from osmosfeed",
      "feedUrl": "https://github.com/osmoscraft/osmosfeed/releases.atom",
      "siteUrl": "https://github.com/osmoscraft/osmosfeed/releases",
      "articles": []
    },
    {
      "title": "ShanSan",
      "feedUrl": "https://shansan.top/rss2",
      "siteUrl": "https://yeshan333.github.io/",
      "articles": [
        {
          "id": "https://yeshan333.github.io/2021/12/04/deserve/",
          "author": null,
          "description": "今天凌晨五点就醒了，积累了好多好多的情绪啊！",
          "link": "https://yeshan333.github.io/2021/12/04/deserve/",
          "publishedOn": "2021-12-04T06:49:35.000Z",
          "wordCount": 101,
          "title": "Deserve"
        },
        {
          "id": "https://yeshan333.github.io/2021/11/27/loopback-addr/",
          "author": null,
          "description": "心血来潮，小水一篇！\n回环地址（loopback address）\n\nloopback 在维基百科上有一段这样的解释：Loopback (also written loop-back) is the routing of electronic signals or digital data streams back to their source without intentional processing or modification. It is primarily a means of testing the communications infrastructure.\n通熟的说就是将由“源”发送出去的数据路由回“源”。",
          "link": "https://yeshan333.github.io/2021/11/27/loopback-addr/",
          "publishedOn": "2021-11-27T11:41:50.000Z",
          "wordCount": 332,
          "title": "回环地址的一点儿破事"
        },
        {
          "id": "https://yeshan333.github.io/2021/11/14/back-to-october/",
          "author": null,
          "description": "<script src=\"/assets/js/APlayer.min.js\"",
          "link": "https://yeshan333.github.io/2021/11/14/back-to-october/",
          "publishedOn": "2021-11-14T10:21:37.000Z",
          "wordCount": 219,
          "title": "回到十月-生活中的一点儿小确幸"
        }
      ]
    },
    {
      "title": "酷 壳 – CoolShell",
      "feedUrl": "https://coolshell.cn/feed",
      "siteUrl": "https://coolshell.cn",
      "articles": [
        {
          "id": "https://coolshell.cn/?p=21649",
          "author": "陈皓",
          "description": "最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains...\n Read More  Read More\n源代码特洛伊木马攻击 first appeared on 酷 壳 - CoolShell.",
          "link": "https://coolshell.cn/articles/21649.html",
          "publishedOn": "2021-11-19T09:02:46.000Z",
          "wordCount": 999,
          "title": "源代码特洛伊木马攻击"
        }
      ]
    },
    {
      "title": "面向信仰编程",
      "feedUrl": "https://draveness.me/feed.xml",
      "siteUrl": "https://draveness.me/",
      "articles": [
        {
          "id": "https://draveness.me//golang-book-release",
          "author": null,
          "description": "",
          "link": "https://draveness.me//golang-book-release",
          "publishedOn": "2021-11-20T00:00:00.000Z",
          "wordCount": 81,
          "title": "《Go 语言设计与实现》纸质书预售了！"
        }
      ]
    },
    {
      "title": "卡瓦邦噶！",
      "feedUrl": "https://www.kawabangga.com/feed",
      "siteUrl": "https://www.kawabangga.com",
      "articles": [
        {
          "id": "https://www.kawabangga.com/?p=4617",
          "author": "laixintao",
          "description": "记录一个今天遇到的小问题。这是继 Debug 一个在 uWSGI 下使用 subprocess 卡住的问题 之 […]\nContinue reading...\nThe post 寻找丢失的信号 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\nuWSGI socket 队列被占满的问题\nDebug 一个在 uWSGI 下使用 subprocess 卡住的问题\n如何杀死一个进程？\nSRE&Devops 每周分享 Issue #3\n我的线程池怎么没了？",
          "link": "https://www.kawabangga.com/posts/4617",
          "publishedOn": "2021-11-26T14:25:38.000Z",
          "wordCount": 938,
          "title": "寻找丢失的信号"
        },
        {
          "id": "https://www.kawabangga.com/?p=4607",
          "author": "laixintao",
          "description": "周末看了一下 coredns 的源代码，目前为止只是差不多搞清楚了这个代码库的逻辑。写篇博客记录一下，如果你也 […]\nContinue reading...\nThe post Coredns 源码阅读（导读） first appeared on 卡瓦邦噶！.\n\n相关文章:\n\nJoin Shopee & Work with Me!\n辅助Django开发的一些隐藏资源（文档）\n一些命令行工具的增强版\n实时上传数据备份文件到S3",
          "link": "https://www.kawabangga.com/posts/4607",
          "publishedOn": "2021-11-14T10:43:09.000Z",
          "wordCount": 545,
          "title": "Coredns 源码阅读（导读）"
        }
      ]
    },
    {
      "title": "MoeLove",
      "feedUrl": "https://moelove.info/index.xml",
      "siteUrl": "https://moelove.info/",
      "articles": [
        {
          "id": "https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。\n对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。\n我们先对这两项技术的作用做个概括：\ncgroup 的主要作用：管理资源的分配、限制；\nnamespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；\n在上一篇文章中，我们重点聊了 cgroup 。本篇，我们重点来聊 namespace 。\nNamespace 是什么？\n我们引用 wiki 上对 namespace 的定义：\nNamespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.\nnamespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。\n这样的说法未免太绕了些，简单来说 name…",
          "link": "https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/",
          "publishedOn": "2021-12-09T19:50:29.000Z",
          "wordCount": 873,
          "title": "搞懂容器技术的基石： namespace （上）"
        },
        {
          "id": "https://moelove.info/2021/12/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.23.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。\nKubernetes v1.23 即将发布，这是 2021 年发布的第三个版本，也是今年最后一个正式发布的版本。\n此版本中主要包括 47 项增强更新，其中 11 项达到 stable, 17 项达到 beta 还有 19 项达到 alpha 。 当然，也有 1 项被标记为废弃。相比于 v1.22 从数量上来说是少了一点（v1.22 有 53 项增强更新），但这并不影响这是一个很棒的版本！\n在 Kubernetes 的发布周期变更为 每4个月一个版本 后，很明显的感觉就是不用在升级上面花费太多时间了，毕竟 Kubernetes 的升级操作是个体力活，大家觉得呢？\n我们一起来看看这个版本中有哪些值得关注的变更吧！\n新增 kubectl alpha events 命令\n在之前的 《K8S 生态周报| Helm 新版本发布增强对 OCI 的支持》 文章的上游进展中我曾为大家介绍了该功能。它是按照 KEP #1440 实施的。\n增加此命令主要是由于在不修改 kubectl get 的前提下，查看 event 有一些限制，所以直接增加 kubectl events 命令可以更方便的去获取到需要的信息，尤其是 event 是在 Kubernetes 中经常需要查看的一个信息。kubectl get events 比较典型的一些问题, 比如排序（虽然可以通过加参数解决）， watch，以及无法按照时间线方式去查看 events 等。\n我们来看看这个命令具体如何使用。\n我们先来创建两个 Pod，分别叫 redis 和 redis2 。\n(MoeLove) ➜ kubectl run redis --image=\"ghcr.io/tao12345666333/redis:a…",
          "link": "https://moelove.info/2021/12/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.23.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/",
          "publishedOn": "2021-12-07T19:50:29.000Z",
          "wordCount": 589,
          "title": "K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览"
        },
        {
          "id": "https://moelove.info/2021/12/06/Open-Policy-Agent-OPA-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n本篇我来为你介绍一个我个人很喜欢的，通用策略引擎，名叫 OPA，全称是 Open Policy Agent。\n在具体聊 OPA 之前，我们先来聊一下为什么需要一个通用策略引擎，以及 OPA 解决了什么问题。\nOPA 解决了什么问题\n在实际的生产环境中很多场景中都需要策略控制，比如：\n需要策略控制用户是否可登陆服务器或者做一些操作；\n需要策略控制哪些项目/哪些组件可进行部署；\n需要策略控制如何访问数据库；\n需要策略控制哪些资源可部署到 Kubernetes 中；\n\n但是对于这些场景或者软件来说，配置它们的策略是需要与该软件进行耦合的，彼此是不统一，不通用的。管理起来也会比较混乱，带来了不小的维护成本。\nOPA 的出现可以将各处配置的策略进行统一，极大的降低了维护成本。以及将策略与对应的软件/服务进行解耦，方便进行移植/复用。\n\nOPA 的发展过程\nOPA 最初是由 Styra 公司在 2016 年创建并开源的项目，目前该公司的主要产品就是提供可视化策略控制及策略执行的可视化 Dashboard 服务的。\nOPA 首次进入 CNCF 并成为 sandbox 级别的项目是在 2018 年， 在 2021 年的 2 月份便已经从 CNCF 毕业，这个过程相对来说还是比较快的，由此也可以看出 OPA 是一个比较活跃且应用广泛的项目。\nOPA 是什么\n前面我们已经介绍过 Open Policy Agent (OPA) 是一种开源的通用策略引擎，可在整个堆栈中实现统一、上下文感知的策略控制。\nOPA 可将策略决策与应用程序的业务逻辑分离（解耦），透过现象看本质，策略就是一组规则，请求发送到引擎，引擎根据规则来进行决策。\n\n图 3 ，OPA 的策略解耦示例\nOPA 并不负责具体任务的执行，它仅负责决策，需要决策的请求通过 JSON 的方式传递给 OPA ，在 OPA …",
          "link": "https://moelove.info/2021/12/06/Open-Policy-Agent-OPA-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/",
          "publishedOn": "2021-12-06T11:50:29.000Z",
          "wordCount": 593,
          "title": "Open Policy Agent (OPA) 入门实践"
        },
        {
          "id": "https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n在我之前发布的文章 《云原生时代下的容器镜像安全》（系列）中，我提到过 Kubernetes 集群的核心组件 -- kube-apiserver，它允许来自终端用户或集群的各组件与之进行通信（例如，查询、创建、修改或删除 Kubernetes 资源）。\n本篇我们将聚焦于 kube-apiserver 请求处理过程中一个很重要的部分 -- 准入控制器（Admission Controller）\nK8s 的准入控制器是什么\nK8s 中的请求处理流程\n在聊 K8s 准入控制器是什么之前，让我们先来回顾一下 Kubernetes API 的处理具体请求的过程。\n\n图 1 ，Kubernetes API 处理请求的过程 （从 API Handler 到 etcd 持久化的过程）\n如上图所示，每个 API 的请求从开始被 kube-apiserver 接收到最终持久化到 ETCD 的过程，即为 Kubernetes API 的请求处理流程。\n它主要包含了以下几个部分：\nAPI Handler -- 主要负责提供服务，接收请求。\n对于其内部实现而言，请求会先到 FullHandlerChain （它是由 DefaultBuildHandlerChain 构建出来的）是一个 director 对象\ntype director struct {\nname string\ngoRestfulContainer *restful.Container\nnonGoRestfulMux *mux.PathRecorderMux\n}\n\n\ndirector根据配置进行初始化，如果 goRestfulContainer的 WebServices 的 RootPath 是 /apis，或者请求前缀与 RootPath 匹配，则进入 Restful 处理链路。\nAuthentication …",
          "link": "https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/",
          "publishedOn": "2021-11-29T19:04:22.000Z",
          "wordCount": 799,
          "title": "理清 Kubernetes 中的准入控制（Admission Controller)"
        },
        {
          "id": "https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\nPrometheus 几乎已经成为了云原生时代下监控选型的事实标准，它也是第二个从 CNCF 毕业的项目。\n当前，Prometheus 几乎可以满足各种场景/服务的监控需求。我之前有写过一些文章介绍过 Prometheus 及其生态，本篇我们将聚焦于 Prometheus 最新版本中发布的 Agent 模式，对于与此主题无关的一些概念或者用法，我会粗略带过。\n拉模式（Pull）和 推模式（Push）\n众所周知，Prometheus 是一种拉模式（Pull）的监控系统，这不同于传统的基于推模式（Push）的监控系统。\n什么是拉模式（Pull）呢？\n\n待监控的服务自身或者通过一些 exporter 暴露出来一些 metrics 指标的接口，由 Prometheus 去主动的定时进行抓取/采集，这就是拉模式（Pull）。即由监控系统主动的去拉（Pull）目标的 metrics。\n与之相对应的就是推模式（Push）了。\n\n由应用程序主动将自身的一些 metrics 指标进行上报，监控系统再进行相对应的处理。如果对于某些应用程序的监控想要使用推模式（Push），比如：不易实现 metrics 接口等原因，可以考虑使用 Pushgateway 来完成。\n对于拉模式（Pull）和推模式（Push）到底哪种更好的讨论一直都在继续，有兴趣的小伙伴可以自行搜索下。\n这里主要是聚焦于单个 Prometheus 和应用服务之间交互的手方式。本篇我们从更上层的角度或者全局角度来看看当前 Prometheus 是如何做 HA、 持久化和集群的。\nPrometheus HA/持久化/集群的方案\n在大规模生产环境中使用时，很少有系统中仅有一个单实例 Prometheus 存在的情况出现。无论从高可用、数据持久化还是从为用户提供更易用的全局视图来考虑，运行多个 Prometheus 实…",
          "link": "https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/",
          "publishedOn": "2021-11-27T16:26:44.000Z",
          "wordCount": 694,
          "title": "新功能：Prometheus Agent 模式上手体验"
        },
        {
          "id": "https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n近期 Rust 社区/团队有些变动，所以再一次将 Rust 拉到大多数人眼前。\n我最近看到很多小伙伴说的话：\nRust 还值得学吗？社区是不是不稳定呀\nRust 和 Go 哪个好？\nRust 还值得学吗？\n这些问题如果有人来问我，那我的回答是：\n小孩子才做选择，我都要！\n当然，关于 Rust 和 Go 的问题也不算新，比如之前的一条推文：\n\n我在本篇中就来介绍下如何用 Go 调用 Rust。\n当然，这篇中我基本上不会去比较 Go 和 Rust 的功能，或者这种方式的性能之类的，Just for Fun\nFFI 和 Binding\nFFI (Foreign Function Interface) 翻译过来叫做外部函数接口（为了比较简单，下文中都将使用 FFI 指代）。最早来自于 Common Lisp 的规范，这是在 wiki 上写的，我并没有去考证。\n不过我所使用过的绝大多数语言中都有 FFI 的概念/术语存在，比如：Python、Ruby, Haskell、Go、Rust、LuaJIT 等。\nFFI 的作用简单来说就是允许一种语言去调用另一种语言，有时候我们也会用 Binding 来表示类似的能力。\n在不同的语言中会有不同的实现，比如在 Go 中的 cgo , Python 中的 ctypes ， Haskell 中的 CAPI （之前还有一个 ccall）等。\n我个人感觉 Haskell 中用 FFI 相比其他语言要更简单&方便的多，不过这不是本篇的重点就不展开了。\n在本文中，对于 Go 和 Rust 而言，它们的 FFI 需要与 C 语言对象进行通信，而这部分其实是由操作系统根据 API 中的调用约定来完成的。\n我们来进入正题。\n准备 Rust 示例程序\nRust 的安装和 Cargo 工具的基本使用，这里就不介绍了。大家可以去 Rust 的官网…",
          "link": "https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/",
          "publishedOn": "2021-11-25T19:04:22.000Z",
          "wordCount": 458,
          "title": "用 Go 调用 Rust"
        },
        {
          "id": "https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\nKubernetes 作为云原生的基石，为我们带来了极大的便利性，越来越多的公司也都将 Kubernetes 应用到了生产环境中。然而，在享受其带来的便利性的同时，我们也需要关注其中的一些安全隐患。\n本篇，我将为你重点介绍容器镜像安全相关的内容。\n通常情况下，我们提到容器镜像安全，主要是指以下两个方面：\n镜像自身内容的安全；\n镜像分发过程的安全；\n镜像自身内容的安全\n要聊镜像自身内容的安全，那我们就需要知道镜像到底是什么，以及它其中的内容是什么。\n镜像是什么\n我们以 debian镜像为例，pull 最新的镜像，并将其保存为 tar 文件，之后进行解压：\n➜ ~ mkdir -p debian-image\n➜ ~ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\n647acf3d48c2: Pull complete\nDigest: sha256:e8c184b56a94db0947a9d51ec68f42ef5584442f20547fa3bd8cbd00203b2e7a\nStatus: Downloaded newer image for debian:latest\ndocker.io/library/debian:latest\n➜ ~ docker image save -o debian-image/debian.tar debian\n➜ ~ ls debian-image\ndebian.tar\n➜ ~ tar -C debian-image -xf debian-image/debian.tar\n➜ ~ tree -I debian.tar debian-image\ndebian-image\n├── 827e5611389abf13d…",
          "link": "https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/",
          "publishedOn": "2021-11-23T15:16:42.000Z",
          "wordCount": 536,
          "title": "云原生时代下的容器镜像安全（上）"
        },
        {
          "id": "https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n提到 Shell 大家想必不会太陌生，我们通常认为 Shell 是我们和系统交互的接口，执行命令返回输出，比如 bash 、zsh 等。偶尔也会有人把 Shell 和 Terminal（终端）混淆，但这和本文关系不大，暂且略过。\n作为一名程序员，我们可能天天都会用到 Shell ，偶尔也会把一些命令组织到一起，写个 Shell 脚本之类的，以便提升我们的工作效率。\n然而在看似简单的 Shell 脚本中，可能隐藏着很深的坑。这里我先给出两段简单且相似的 Shell 脚本，大家不妨来看看这两段代码的输出是什么：\n#!/bin/bash\nset -e -u\ni=0\nwhile [ $i -lt 6 ]; do\necho $i\n((i++))\ndone\n\n答案是只会输出一个 0 。\n#!/bin/bash\nset -e -u\nlet i=0\nwhile [ $i -lt 6 ]; do\necho $i\n((i++))\ndone\n\n答案是没有任何输出，直接退出。\n如果你能解释清楚上面两段代码输出结果的话， 那大概你可以跳过这篇文章后续的内容了。\n我先来分解下这段代码中涉及到的主要知识点。\n变量声明\n变量声明有很多种办法， 但是其行为却各有不同。\n我们必须先有个基础认识： Bash 没有类型系统，所有变量都是 string 。 基于这个原因，如果是让变量进行算术运算时，不能像在其他的编程语言中那样直接写算术运算符。这会让 bash 解释为对 string 的操作，而不是对数字的操作。\n直接声明\n(MoeLove)➜ ~ foo=1+1\n(MoeLove)➜ ~ echo $foo\n1+1\n\n直接声明最简单，但正如前面提到的，直接声明会默认当作 string 进行处理，不能在声明时进行算术运算。\ndeclare 声明\n(MoeLove)➜ ~ declare foo…",
          "link": "https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/",
          "publishedOn": "2021-11-21T14:41:02.000Z",
          "wordCount": 736,
          "title": "Shell 脚本避坑指南（一）"
        },
        {
          "id": "https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。\n对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。\n我们先对这两项技术的作用做个概括：\ncgroup 的主要作用：管理资源的分配、限制；\nnamespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；\n本篇，我们重点来聊 cgroup 。\n为什么要关注 cgroup & namespace\n云原生/容器技术的井喷式增长\n自 1979年，Unix 版本7 在开发过程中引入 Chroot Jail 以及 Chroot 系统调用开始，直到 2013 年开源出的 Docker，2014 年开源出来的 Kubernetes，直到现在的云原生生态的火热。 容器技术已经逐步成为主流的基础技术之一。\n在越来越多的公司、个人选择了云服务/容器技术后，资源的分配和隔离，以及安全性变成了人们关注及讨论的热点话题。\n其实容器技术使用起来并不难，但要真正把它用好，大规模的在生产环境中使用， 那我们还是需要掌握其核心的。\n以下是容器技术&云原生生态的大致发展历程：\n\n图 1 ，容器技术发展历程\n从图中，我们可以看到容器技术、云原生生态的发展轨迹。容器技术其实很早就出现了，但为何在 Docker 出现后才开始有了较为显著的发展？早期的 chroot 、 Linux VServer 又有哪些问题呢？\nChroot 带来的安全性问题\n\n图 2 ，chroot 示例\nChroot 可以将进程及其子进程与操作系统的其余部分隔离开来。但是，对于 root process ，却可以任意退出 chroot。\npackage main\nimport (\n\"log\"\n\"os\"\n\"sy…",
          "link": "https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/",
          "publishedOn": "2021-11-17T15:16:42.000Z",
          "wordCount": 822,
          "title": "一篇搞懂容器技术的基石： cgroup"
        }
      ]
    },
    {
      "title": "CJ Ting's Blog",
      "feedUrl": "https://cjting.me/index.xml",
      "siteUrl": "https://cjting.me/",
      "articles": []
    },
    {
      "title": "codedump的网络日志",
      "feedUrl": "https://www.codedump.info/index.xml",
      "siteUrl": "https://www.codedump.info/",
      "articles": []
    }
  ],
  "cliVersion": "1.11.3"
}