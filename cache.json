{
  "sources": [
    {
      "title": "Release notes from osmosfeed",
      "feedUrl": "https://github.com/osmoscraft/osmosfeed/releases.atom",
      "siteUrl": "https://github.com/osmoscraft/osmosfeed/releases",
      "articles": []
    },
    {
      "title": "ShanSan",
      "feedUrl": "https://shansan.top/rss2",
      "siteUrl": "https://yeshan333.github.io/",
      "articles": [
        {
          "id": "https://yeshan333.github.io/2022/02/26/profiling-flame-graph/",
          "author": null,
          "description": "<script src=\"/assets/js/APlayer.min.js\"",
          "link": "https://yeshan333.github.io/2022/02/26/profiling-flame-graph/",
          "publishedOn": "2022-02-26T22:54:38.000Z",
          "wordCount": 354,
          "title": "profiling & Flame Graphs",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "酷 壳 – CoolShell",
      "feedUrl": "https://coolshell.cn/feed",
      "siteUrl": "https://coolshell.cn",
      "articles": []
    },
    {
      "title": "面向信仰编程",
      "feedUrl": "https://draveness.me/feed.xml",
      "siteUrl": "https://draveness.me/",
      "articles": [
        {
          "id": "https://draveness.me//kuberentes-federation",
          "author": null,
          "description": "",
          "link": "https://draveness.me//kuberentes-federation",
          "publishedOn": "2022-03-19T00:00:00.000Z",
          "wordCount": 569,
          "title": "Kubernetes、集群联邦和资源分发",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "卡瓦邦噶！",
      "feedUrl": "https://www.kawabangga.com/feed",
      "siteUrl": "https://www.kawabangga.com",
      "articles": [
        {
          "id": "https://www.kawabangga.com/?p=4663",
          "author": "laixintao",
          "description": "最近用了 @yiran 转载的一个 pocket 的隐藏功能，发现太好用了。在博客上单独再分享一下。 TL;D […]\nContinue reading...\nThe post 分享一下“稍后阅读”的 random 功能 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\nSRE&Devops 每周分享 Issue #1 Opening\nFirefox Setup\n近况\njava问答：终极父类（六）——等待/唤醒和接口\n玩了一下 Github 个人首页的 Profile （使用 Action 自动更新）",
          "link": "https://www.kawabangga.com/posts/4663",
          "publishedOn": "2022-03-18T16:28:45.000Z",
          "wordCount": 425,
          "title": "分享一下“稍后阅读”的 random 功能",
          "imageUrl": null
        },
        {
          "id": "https://www.kawabangga.com/?p=4649",
          "author": "laixintao",
          "description": "最近在跨机房做一个部署，因为机房之间暂时没有专线，所以流量需要经过公网。对于经过公网的流量，我们一般需要做以下 […]\nContinue reading...\nThe post 用 Nginx 在公网上搭建加密数据通道 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\n部署 Django 项目背后的原理：为什么需要 Nginx 和 Gunicron这些东西？\nNginx if 指令工作原理\n使用 ngx_lua （openresty）正确读取 HTTP 请求 body\n单页应用的登陆验证方式\n如何杀死一个进程？",
          "link": "https://www.kawabangga.com/posts/4649",
          "publishedOn": "2022-03-16T11:10:28.000Z",
          "wordCount": 2047,
          "title": "用 Nginx 在公网上搭建加密数据通道",
          "imageUrl": null
        },
        {
          "id": "https://www.kawabangga.com/?p=4626",
          "author": "laixintao",
          "description": "今年没有在跨年的时候及时写完年终总结，是因为那天还在西安隔离。2021 年一整年依然是疫情肆虐，下半年在新加坡 […]\nContinue reading...\nThe post 2021 年年鉴 first appeared on 卡瓦邦噶！.\n\n相关文章:\n\n我在新加坡一个月的生活费明细\n为什么 Cloudflare 提供免费的服务？\nBuild 一个最小的 Redis Docker Image\n《Prometheus Up & Running》阅读\n使用 mtr 检查网络问题，以及注意事项",
          "link": "https://www.kawabangga.com/posts/4626",
          "publishedOn": "2022-02-25T16:24:42.000Z",
          "wordCount": 555,
          "title": "2021 年年鉴",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "MoeLove",
      "feedUrl": "https://moelove.info/index.xml",
      "siteUrl": "https://moelove.info/",
      "articles": [
        {
          "id": "https://moelove.info/2022/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Argo-Workflows-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。\nTrivy 新版本发布\n本周 Trivy 相继发布了 v0.24.3 和 v0.24.4 版本。最需要关注的变更是如下两个：\n#1791 更新了 hcl2json 的版本，以便于修正 hcl2json 在处理无效 HCL 配置时的发生的 panic;\n#1852 修正了一个自 v0.24.3 开始引入的 bug, 如果不提供镜像的 tag，在 v0.24.3 中将会报错，现在会遵循 Docker 的相关行为，如果不提供 tag 则默认使用 latest ；\n更多详情请参考其 ReleaseNote\nArgo Workflows v3.3 正式发布\nArgo Workflows 是一个 Kubernetes 上的通用 Workflow 引擎，近期发布的 v3.3 是它的一个特性版本。这里我主要列几个我所关注的变更：\nPlugin template 允许开发者使用任何语言对 workflow 进行扩展，这是一个非常棒的特性。在之前，如果我们想在 Workflow 中执行一些通知，或者做一些报告，那么我可能需要添加一个新的步骤。这样会让整个流程变长。而且，假如我需要上一步的执行结果或输出，那么我还需要单独的处理参数传递等事情，很繁琐。但是，v3.3 中增加的这个 Plugin template 能力，就让事情变得很简单了。比如我可以使用如下配置进行消息通知：\napiVersion: argoproj.io/v1alpha1\nkind: Workflow\nmetadata:\n generateName: plugin-example-\nspec:\n entrypoint: main\n templates:\n - name: main\n plugin:\n webh…",
          "link": "https://moelove.info/2022/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Argo-Workflows-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/",
          "publishedOn": "2022-03-20T16:01:32.000Z",
          "wordCount": 310,
          "title": "K8S 生态周报| Argo Workflows 新版本发布，带来众多新特性",
          "imageUrl": "https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png"
        },
        {
          "id": "https://moelove.info/2022/03/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.8-OCI-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%BC%8F-GADocker-%E6%96%B0%E7%89%88%E6%9C%AC%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E4%B8%A5%E9%87%8D-bug/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。\nKIND v0.12.0 发布\nKIND（Kubernetes In Docker）是我很喜欢，也是一直在参与的一个开源项目。\n在我之前的文章中有过多次介绍，可以参考\n我基本上每天都会用到它，非常的方便。\n距离上个大版本，v0.11 已经过了近十个月，我们来看看这个新版本带来哪些值得关注的特性吧：\n目前 v0.12.0 默认使用的 Kubernetes 版本为 v1.23.4 版本。如果升级 KIND 的话，会重新拉取最新的镜像，镜像托管在 Docker Hub 上，\n可能会比较耗时，建议确保网络顺畅。\n在 v0.12.0 中专门优化了对多架构的支持，默认的所有已发布镜像都包含了 amd64 和 arm64 的支持。\n在镜像中也对相关组件都做了升级：\ncontainerd v1.5.10\ncrictl 1.23.0\nCNI plugin v1.1.0\n此外，也修复了 Docker + cgroup2 + rootless 环境下的支持，和 WSL2 环境下的支持。建议大家进行升级。\n更多详细信息请参考其 ReleaseNote\nDocker v20.10.13 发布\n本周 Docker 发布了 v20.10.13 版本，是的，你没有看错，现在发布的版本还是在给 v20.10 打 patch 。\n实际上当前 Docker 仓库中最新的代码比 v20.10 已经多了很多功能特性，只不过尚未达到发布一个全新的大版本的目标，所以一直没有发布新的大版本。\n这个版本中主要是进行了一些 bugfix 和打包相关的变更。其中包括：\n将 buildx 升级到了 v0.8.0 版本。\n#43165 修复了当使用 local 日志驱动时，如果迅速产生大量日志，可能会产生 OO…",
          "link": "https://moelove.info/2022/03/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.8-OCI-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%BC%8F-GADocker-%E6%96%B0%E7%89%88%E6%9C%AC%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E4%B8%A5%E9%87%8D-bug/",
          "publishedOn": "2022-03-11T18:34:36.000Z",
          "wordCount": 387,
          "title": "K8S 生态周报| Helm v3.8 OCI 支持正式 GA，Docker 新版本修复多个严重 bug",
          "imageUrl": "https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png"
        },
        {
          "id": "https://moelove.info/2022/03/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Knative-%E8%BF%9B%E5%85%A5-CNCF-%E5%AD%B5%E5%8C%96K8S-ingress-nginx-%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。\nKubernetes ingress-nginx v1.1.2 发布\n就在今天 Kubernetes ingress-nginx 项目发布了 v1.1.2 版本。\n我是这个版本的 release manager 。\n距离上个版本发布有将近两个月了，我们来看看这个版本中值得关注的一些变更。\n在 #8221 中，我们对 ingress-nginx 的 Admission controller 的逻辑做了一些调整，\n主要是可以用来修正 自 v1.0 版本后，如果 Kubernetes 集群中同时运行多个 ingress-nginx 的话，在创建 Ingress 资源的时候，可能导致每个 ingres-nginx 的 Admission 都会去进行检查的问题。\n而该问题最大的影响是，如果创建的 Ingress 配置相同的话，则会被直接拒绝掉。\n在 #8253 中则是为 ingress-nginx 增加了一个 ssl_certificate_info 的 metric， 直接公开当前被加载的证书的信息。\n这个功能的最大的好处就是可以避免 Ingress controller Pod 加载了旧证书，进而导致客户端连接失败的问题。\n此外 #8256 是为了修正在 nginx.ingress.kubernetes.io/auth-url 中传递无效 URL 的问题，\n建议升级 。\n此外还有一些小的 bugfix 和优化，更多详细信息请参考 ReleaseNote 。\n在这次发布过程中还有一些比较有趣的事情，\n本次发布过程从时间线看，从我开始发布流程，到最后完成发布，共持续了一周的时间，由几个人异步协作完成。\n这跟往常差别还是比较大的，往常我们可能会约某个时间，同时在线一…",
          "link": "https://moelove.info/2022/03/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Knative-%E8%BF%9B%E5%85%A5-CNCF-%E5%AD%B5%E5%8C%96K8S-ingress-nginx-%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/",
          "publishedOn": "2022-03-06T15:39:51.000Z",
          "wordCount": 286,
          "title": "K8S 生态周报| Knative 进入 CNCF 孵化，K8S ingress-nginx 解决多实例问题",
          "imageUrl": "https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png"
        },
        {
          "id": "https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/",
          "author": "zhangjintao9020@gmail.com (张晋涛)",
          "description": "大家好，我是张晋涛。\n在之前的 『K8S生态周报』 和 《搞懂 Kubernetes 准入控制（Admission Controller)》 等文章中，我曾提到过 Kyverno 这个云原生策略引擎项目，很多小伙伴在后台私信我说对这个项目比较感兴趣。这篇文章我们专门来聊聊 Kyverno 吧。\nKyverno 当前是一个 CNCF sandbox 级别的项目。\n\n本文的大纲如下，小伙伴们可自行跳跃到感兴趣的部分查阅。\n\nKubernetes 的策略\n我们称 Kyverno 是云原生策略引擎，那么 Kubernetes 中的策略是什么呢？\n对于 Kubernetes 中的策略，大家可能比较熟悉的是 PodSecurityPolicy。 不过 PodSecurityPolicy 自 Kubernetes v1.21 起已弃用，并将在 v1.25 中删除（当前版本是 v1.23 ）。当前建议大家迁移到 Kubernetes 新增的替换方案 Pod Security Admission 或者类似本文中介绍的 Kyverno 等这种第三方策略插件。\n其实无论是 PodSecurityPolicy 还是它的替代方案 Pod Security Admission ，甚至包括 Kyverno 等，它们都是构筑在 Kubernetes 的 Admission 机制之上的。\n首先，我们主要从两个角度来理解为什么我们需要准入控制器（Admission Controller）：\n从安全的角度\n比如，为避免攻击。需要对Kubernetes 集群中部署的镜像来源判定；\n比如，避免 Pod 使用 root 用户，或者尽量不开启特权容器等；\n从治理的角度\n比如，通过 admission controller 校验服务是否拥有必须的 label；\n比如，避免出现资源超卖等；\n下图，是 kube-apiser…",
          "link": "https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/",
          "publishedOn": "2022-03-02T13:39:12.000Z",
          "wordCount": 479,
          "title": "云原生策略引擎 Kyverno （上）",
          "imageUrl": "https://s2.loli.net/2022/03/03/KUYpoEOH9SFIdL3.png"
        }
      ]
    },
    {
      "title": "CJ Ting's Blog",
      "feedUrl": "https://cjting.me/index.xml",
      "siteUrl": "https://cjting.me/",
      "articles": []
    },
    {
      "title": "codedump的网络日志 on codedump的网络日志",
      "feedUrl": "https://www.codedump.info/index.xml",
      "siteUrl": "https://www.codedump.info/",
      "articles": [
        {
          "id": "https://www.codedump.info/post/20220319-weekly-10/",
          "author": null,
          "description": "引言：本期聊一聊《掌控习惯》这本书里提到的养成习惯的方法论。我读下来一个最深的感受是：越不需要“坚持”就能做下去的事情，才越能长久做下去。\n“忘记目标，专注于体系”\n“忘记目标，专注于体系（Forget About Setting Goals, Focus on the system Instead）”是出自《Atomic Habits》（中文名《掌控习惯 》）一书的一句话，个人认为这是本书最重要的一个观点。\n要做成一件事情，只是依靠简单的设定目标，是远远不够的，更重要的是建立一套体系，促进事情的良性循环，最终让事情发生；反之，如果一件不好的事情，经常重蹈覆辙，其根本原因也是从未改变导致这种状况一再发生的体系。如果没有建立一套体系，所做的一切只是治标不治本。\n这里说的“体系”，在作者的话语中就是“习惯”，作者列出了培养良好习惯的四个步骤（提示、渴求、反应和奖励）：\n1、提示：让它显而易见。\n\n\n\n2、渴求：让它有吸引力。\n\n\n\n3、反应：让它简便易行。\n\n\n\n4、奖励：让它令人愉悦。\n\n\n\n作者将这四个步骤，总结在习惯循环（habit-loop）里，如下图：\n这四个步骤缺一不可，任何一个环节做的不够的话，就难以形成习惯：\n消除提示，习惯形成循环永远也不会开始。\n降低渴求，就不会有足够的动力去行动。\n让行动变得困难，将无法付诸实施。\n如果奖励不能满足欲望，那么未来就没有理由再这样做了。\n没有前三步，就不会有任何行为发生。没有这四个步骤，任何一种行为都不会得以重复。\n1、提示：让它显而易见\n在日常行为中，“原动力经常被高估，而环境的作用往往被低估”，比如经常会认为树立一个远大的目标，坚持做下去就好；而现实的情况是，行为是环境中人的函数：\nB（行为）=f（函数）[P（人），E（环境）]\n即有怎样的行为，除了和人有关系之外，还和环境有重要的关系。\n环境函数中，常见的两个提示是时间和…",
          "link": "https://www.codedump.info/post/20220319-weekly-10/",
          "publishedOn": "2022-03-19T05:50:46.000Z",
          "wordCount": 221,
          "title": "周刊（第10期）：“忘记目标，专注于体系”",
          "imageUrl": null
        },
        {
          "id": "https://www.codedump.info/post/20220313-weekly-9/",
          "author": null,
          "description": "引言：在之前的周刊（第7期）：一个C系程序员的Rust初体验中，简单提到过Mozilla rr这款调试工具，由于这个工具并不是太为人所知，所以本文对该工具做一个简介。\nMozilla rr使用简介\nrr是由Mozilla出品的一款调试工具，用官网的话来说：\nrr aspires to be your primary C/C++ debugging tool for Linux, replacing — well, enhancing — gdb. You record a failure once, then debug the recording, deterministically, as many times as you want. The same execution is replayed every time.\n即它的特点是：可以记录下来程序运行时的上下文环境，包括线程、堆栈、寄存器等等，这样的好处有两个：\n“deterministically”：很多问题问题的产生，都与特定的环境相关，如：\n\n\n线程调度执行的顺序，先执行A线程再B线程，以及反之，可能得到的是不同的结果。\n环境参数，如输入不同的参数，尤其一些边界条件的触发就跟输入不同的参数有关。\n\nreplay：记录下来程序执行的环境之后，rr除了支持gdb方式的调试之后，还能利用环境来不停的重放程序，甚至反向来执行程序。\n以下对rr的使用做一些简单的介绍。\ndeterministically\n以下面一个最简单的多线程程序来解释何为deterministically：\n#include <pthread.h>\n#include <stdio.h>\n\nvoid * doPrint(void *arg)\n{\n    return NULL;\n}\n\nint main() {\n    pthread_t pid;\n …",
          "link": "https://www.codedump.info/post/20220313-weekly-9/",
          "publishedOn": "2022-03-13T03:20:59.000Z",
          "wordCount": 597,
          "title": "周刊（第9期）：Mozilla rr使用简介",
          "imageUrl": null
        },
        {
          "id": "https://www.codedump.info/post/20220304-weekly-8/",
          "author": null,
          "description": "引言：写过不少技术文章，以及给不少技术思路手绘示例配图之后，在这方面有了一些心得，本文权当个人的一些的总结，抛砖引玉。\n技术配图的一些心得\n我觉得我们理工科出身的，对于可以量化的事情，总是很容易根据量化差异来做出判断，比如一个程序性能优化之后，能比优化之前快出多少，都能有一个量化的数字来说明。\n但是对于那些不能量化的东西，就很难说出具体好在哪里了。\n本文主题要讨论的“技术配图”就属于这种很难量化的领域，很难有一个标准来量化说明两幅图之间差别在哪里。我也是画了很多图，以及看了别人的很多配图之后，才慢慢有一些心得，本文权当个人的一些的总结，抛砖引玉。\n本文并不是一个画图工具的对比说明，尽管现在各种绘图工具已经很多，也各有自己的优缺点以及个人喜好，但是在这里并不讨论具体工具的使用，会把更多的文字放在配图的一些注意事项上。但是，也总有人问我文章的配图使用什么工具做的，在这里再回答一次：OmniGraffle，一款目前仅有Mac版本的工具软件。\n一图胜千言\n在开始交代具体的配图注意事项之前，有必要先说说配图的重要性。\n绘图，某种程度也是辅助自己思考某个技术点的手段之一，以我个人的体会来说，有时候讲不清楚一个技术点的时候，就手绘图出来，比朴素的文字更容易说明问题。其中的原因，有可能是：图片可以有多维的信息，而文字通常只有一维，遇到文字表达能力不太好的人，这仅有的一维能力可能还不好发挥出来。\n所以，在交代技术细节、沟通交流的时候，尽量多画图。反向的，图画多了，也自然慢慢会找到感觉，如何更好的通过图示表达思路。\n顺便一提，还有比朴素的文字表达更差的技术沟通方式，就是简单粗暴的贴一大段代码上去。这种做法，其实更多时候是没有对作者的思路有太多个人的整理，想偷懒的方式，最后回头再看写过的文字，可能连自己都看不懂了。\n个人的一个体会：如果产出某些输出的时候，能假设自己未来就是这些输出的读者、维护者…",
          "link": "https://www.codedump.info/post/20220304-weekly-8/",
          "publishedOn": "2022-03-04T14:10:11.000Z",
          "wordCount": 249,
          "title": "周刊（第8期）：技术配图的一些心得",
          "imageUrl": null
        },
        {
          "id": "https://www.codedump.info/post/20220227-weekly-7/",
          "author": null,
          "description": "引言：在工作里使用Rust已经有两个多月的时间了，谈谈我做为一名多年的C系（C、C++）程序员，对Rust的初体验。\n一个C系程序员的Rust初体验\n最近由于工作的原因，使用上了Rust语言，在此之前我有多年的C、C++编码经验（以下将C、C++简称C系语言）。\n使用C系语言编码时，最经常面对的问题就是内存问题，诸如：\n野指针（Wild Pointer）：使用了不可知的指针变量，如已经被释放、未初始化、随机，等等。\n内存地址由于访问越界等原因被覆盖（overflow），这不但是可能出错的问题，还有可能成为程序的内存漏洞被利用。\n内存分配后未回收。\n连Chrome的报告都指出，Chrome中大约70%的安全漏洞都是内存问题，见：Memory safety。（不仅如此，微软的文章也显示在微软的产品中70%的安全漏洞也是内存问题，见：Microsoft: 70 percent of all security bugs are memory safety issues | ZDNet）\nC系语言发展到今天，已经有不少可以用于内存问题检测的利器了，其中最好用的莫过于AddressSanitizer，它的原理是在编译时给程序加上一些信息，一旦发生内存越界访问、野指针等错误都会自动检测出来。\n但是即便有这些工具，内存问题也不好解决，其核心的原因在于：这些问题绝大部分都是运行时（Runtime）问题，即要在程序跑到特定场景的时候才会暴露出来，诸如上面提到的AddressSanitizer就是这样。\n都知道解决问题的第一步是能复现问题，而如果一个问题是运行时问题，这就意味着：复现问题可能会是一件很麻烦的事情，有时候还可能到生产环境去复现。\n以我之前经历的一个Bug来看这类工作的复杂度，见线上存储服务崩溃问题分析记录 - codedump的网络日志，这是一个很典型的发生在生产环境上由于内存错误…",
          "link": "https://www.codedump.info/post/20220227-weekly-7/",
          "publishedOn": "2022-02-27T03:25:33.000Z",
          "wordCount": 236,
          "title": "周刊（第7期）：一个C系程序员的Rust初体验",
          "imageUrl": null
        }
      ]
    }
  ],
  "cliVersion": "1.14.4"
}