<!DOCTYPE html>
<html lang="en">

<head>
  <title>osmos::feed</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="noindex, nofollow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="osmos::feed" href="feed.atom" />
  <link href="index.css" rel="stylesheet" />
  <!-- %before-head-end.html% -->
</head>

<body>
<!-- %after-body-begin.html% -->
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-26">2021-11-26</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.kawabangga.com">卡瓦邦噶！</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">寻找丢失的信号</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.kawabangga.com/posts/4617">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>记录一个今天遇到的小问题。这是继 Debug 一个在 uWSGI 下使用 subprocess 卡住的问题 之 […]
Continue reading...
The post 寻找丢失的信号 first appeared on 卡瓦邦噶！.

相关文章:

uWSGI socket 队列被占满的问题
Debug 一个在 uWSGI 下使用 subprocess 卡住的问题
如何杀死一个进程？
SRE&amp;Devops 每周分享 Issue #3
我的线程池怎么没了？</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-25">2021-11-25</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">用 Go 调用 Rust</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>大家好，我是张晋涛。
近期 Rust 社区/团队有些变动，所以再一次将 Rust 拉到大多数人眼前。
我最近看到很多小伙伴说的话：
Rust 还值得学吗？社区是不是不稳定呀
Rust 和 Go 哪个好？
Rust 还值得学吗？
这些问题如果有人来问我，那我的回答是：
小孩子才做选择，我都要！
当然，关于 Rust 和 Go 的问题也不算新，比如之前的一条推文：

我在本篇中就来介绍下如何用 Go 调用 Rust。
当然，这篇中我基本上不会去比较 Go 和 Rust 的功能，或者这种方式的性能之类的，Just for Fun
FFI 和 Binding
FFI (Foreign Function Interface) 翻译过来叫做外部函数接口（为了比较简单，下文中都将使用 FFI 指代）。最早来自于 Common Lisp 的规范，这是在 wiki 上写的，我并没有去考证。
不过我所使用过的绝大多数语言中都有 FFI 的概念/术语存在，比如：Python、Ruby, Haskell、Go、Rust、LuaJIT 等。
FFI 的作用简单来说就是允许一种语言去调用另一种语言，有时候我们也会用 Binding 来表示类似的能力。
在不同的语言中会有不同的实现，比如在 Go 中的 cgo , Python 中的 ctypes ， Haskell 中的 CAPI （之前还有一个 ccall）等。
我个人感觉 Haskell 中用 FFI 相比其他语言要更简单&amp;方便的多，不过这不是本篇的重点就不展开了。
在本文中，对于 Go 和 Rust 而言，它们的 FFI 需要与 C 语言对象进行通信，而这部分其实是由操作系统根据 API 中的调用约定来完成的。
我们来进入正题。
准备 Rust 示例程序
Rust 的安装和 Cargo 工具的基本使用，这里就不介绍了。大家可以去 Rust 的官网…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-23">2021-11-23</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">云原生时代下的容器镜像安全（上）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>大家好，我是张晋涛。
Kubernetes 作为云原生的基石，为我们带来了极大的便利性，越来越多的公司也都将 Kubernetes 应用到了生产环境中。然而，在享受其带来的便利性的同时，我们也需要关注其中的一些安全隐患。
本篇，我将为你重点介绍容器镜像安全相关的内容。
通常情况下，我们提到容器镜像安全，主要是指以下两个方面：
镜像自身内容的安全；
镜像分发过程的安全；
镜像自身内容的安全
要聊镜像自身内容的安全，那我们就需要知道镜像到底是什么，以及它其中的内容是什么。
镜像是什么
我们以 debian镜像为例，pull 最新的镜像，并将其保存为 tar 文件，之后进行解压：
➜ ~ mkdir -p debian-image
➜ ~ docker pull debian
Using default tag: latest
latest: Pulling from library/debian
647acf3d48c2: Pull complete
Digest: sha256:e8c184b56a94db0947a9d51ec68f42ef5584442f20547fa3bd8cbd00203b2e7a
Status: Downloaded newer image for debian:latest
docker.io/library/debian:latest
➜ ~ docker image save -o debian-image/debian.tar debian
➜ ~ ls debian-image
debian.tar
➜ ~ tar -C debian-image -xf debian-image/debian.tar
➜ ~ tree -I debian.tar debian-image
debian-image
├── 827e5611389abf13d…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-21">2021-11-21</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Shell 脚本避坑指南（一）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>大家好，我是张晋涛。
提到 Shell 大家想必不会太陌生，我们通常认为 Shell 是我们和系统交互的接口，执行命令返回输出，比如 bash 、zsh 等。偶尔也会有人把 Shell 和 Terminal（终端）混淆，但这和本文关系不大，暂且略过。
作为一名程序员，我们可能天天都会用到 Shell ，偶尔也会把一些命令组织到一起，写个 Shell 脚本之类的，以便提升我们的工作效率。
然而在看似简单的 Shell 脚本中，可能隐藏着很深的坑。这里我先给出两段简单且相似的 Shell 脚本，大家不妨来看看这两段代码的输出是什么：
#!/bin/bash
set -e -u
i&#x3D;0
while [ $i -lt 6 ]; do
echo $i
((i++))
done

答案是只会输出一个 0 。
#!/bin/bash
set -e -u
let i&#x3D;0
while [ $i -lt 6 ]; do
echo $i
((i++))
done

答案是没有任何输出，直接退出。
如果你能解释清楚上面两段代码输出结果的话， 那大概你可以跳过这篇文章后续的内容了。
我先来分解下这段代码中涉及到的主要知识点。
变量声明
变量声明有很多种办法， 但是其行为却各有不同。
我们必须先有个基础认识： Bash 没有类型系统，所有变量都是 string 。 基于这个原因，如果是让变量进行算术运算时，不能像在其他的编程语言中那样直接写算术运算符。这会让 bash 解释为对 string 的操作，而不是对数字的操作。
直接声明
(MoeLove)➜ ~ foo&#x3D;1+1
(MoeLove)➜ ~ echo $foo
1+1

直接声明最简单，但正如前面提到的，直接声明会默认当作 string 进行处理，不能在声明时进行算术运算。
declare 声明
(MoeLove)➜ ~ declare foo…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-20">2021-11-20</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://draveness.me/">面向信仰编程</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">《Go 语言设计与实现》纸质书预售了！</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://draveness.me//golang-book-release">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(0 min)</span>
                    <span>No content preview</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-19">2021-11-19</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://coolshell.cn">酷 壳 – CoolShell</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">源代码特洛伊木马攻击</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://coolshell.cn/articles/21649.html">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains...
 Read More  Read More
源代码特洛伊木马攻击 first appeared on 酷 壳 - CoolShell.</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-17">2021-11-17</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">一篇搞懂容器技术的基石： cgroup</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。
对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。
我们先对这两项技术的作用做个概括：
cgroup 的主要作用：管理资源的分配、限制；
namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；
本篇，我们重点来聊 cgroup 。
为什么要关注 cgroup &amp; namespace
云原生/容器技术的井喷式增长
自 1979年，Unix 版本7 在开发过程中引入 Chroot Jail 以及 Chroot 系统调用开始，直到 2013 年开源出的 Docker，2014 年开源出来的 Kubernetes，直到现在的云原生生态的火热。 容器技术已经逐步成为主流的基础技术之一。
在越来越多的公司、个人选择了云服务/容器技术后，资源的分配和隔离，以及安全性变成了人们关注及讨论的热点话题。
其实容器技术使用起来并不难，但要真正把它用好，大规模的在生产环境中使用， 那我们还是需要掌握其核心的。
以下是容器技术&amp;云原生生态的大致发展历程：

图 1 ，容器技术发展历程
从图中，我们可以看到容器技术、云原生生态的发展轨迹。容器技术其实很早就出现了，但为何在 Docker 出现后才开始有了较为显著的发展？早期的 chroot 、 Linux VServer 又有哪些问题呢？
Chroot 带来的安全性问题

图 2 ，chroot 示例
Chroot 可以将进程及其子进程与操作系统的其余部分隔离开来。但是，对于 root process ，却可以任意退出 chroot。
package main
import (
&quot;log&quot;
&quot;os&quot;
&quot;sy…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-14">2021-11-14</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://yeshan333.github.io/">ShanSan</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">回到十月-生活中的一点儿小确幸</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://yeshan333.github.io/2021/11/14/back-to-october/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(1 min)</span>
                    <span>前言
不知不觉，离开校园将近四个月了，正式工作（摸🐟~）也差不多四个多月了，最近经历了很多事，头发也掉了不少😂</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.kawabangga.com">卡瓦邦噶！</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Coredns 源码阅读（导读）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.kawabangga.com/posts/4607">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>周末看了一下 coredns 的源代码，目前为止只是差不多搞清楚了这个代码库的逻辑。写篇博客记录一下，如果你也 […]
Continue reading...
The post Coredns 源码阅读（导读） first appeared on 卡瓦邦噶！.

相关文章:

Join Shopee &amp; Work with Me!
辅助Django开发的一些隐藏资源（文档）
一些命令行工具的增强版
实时上传数据备份文件到S3</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-06">2021-11-06</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.kawabangga.com">卡瓦邦噶！</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">SRE 的工作介绍</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.kawabangga.com/posts/4481">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>有很多人问过我想了解一下 SRE 这个岗位，这是个很大的话题，在这篇博客中把想到的一些介绍一下吧。 SRE 到 […]
Continue reading...
The post SRE 的工作介绍 first appeared on 卡瓦邦噶！.

相关文章:

构建大型Cron系统的思考
博客维护：速度优化，嵌入instagram
Python正则表达式解惑
申请友链
DB资料集</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-03">2021-11-03</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">OCI 与下一代镜像构建工具</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/03/OCI-%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>大家好，我是张晋涛。
这篇文章中我将介绍 OCI 及 Docker 镜像相关的内容，欢迎留言讨论。
OCI 的前世今生
2013 年 3 月 dotCloud 公司在 PyCon 上进行了 Docker 的首次展示，随后宣布开源。自此 Docker 开始被众人知晓，随后掀起了一股容器化的热潮。
在 2014 年 6 月 Docker 1.0 正式发布，有近 460 位贡献者和超过 8700 次提交，这也标志着 Docker 达到了生产可用的状态。
在当时，提到容器化第一想法就是用 Docker 。而当时 Docker 的实现或者说发展方向主要是由 Docker Inc. 公司控制的，并没有一个统一的工业标准。这对于一些头部公司而言，显然是不能接受的，没有统一的工业标准意味着如果选择了使用 Docker 的容器化技术，便会被 Docker Inc. 公司所绑定；加上随着 Docker 软件的升级，某些功能或者特性必然会进行变动，没人能保证不发生破坏性变更。
所以，为了推进容器化技术的工业标准化，2015 年 6 月在 DockerCon 上 Linux 基金会与 Google，华为，惠普，IBM，Docker，Red Hat，VMware 等公司共同宣布成立开放容器项目(OCP)，后更名为 OCI。它的主要目标便是 建立容器格式和运行时的工业开放通用标准。
发展至今， OCI 制定的主要标准有三个分别是 runtime-spec 、image-spec 和 distribution-spec 这三个标准分别定义了容器运行时，容器镜像还有分发的规范，后面会展开介绍。
为了支持 OCI 容器运行时标准的推进，Docker 公司起草了镜像格式和运行时规范的草案，并将 Docker 项目的相关实现捐献给了 OCI 作为容器运行时的基础实现，现在项目名为 runc 。
后来 Docke…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-10-30">2021-10-30</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">K8S 生态周报| Helm 新版本发布增强对 OCI 的支持</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%A2%9E%E5%BC%BA%E5%AF%B9-OCI-%E7%9A%84%E6%94%AF%E6%8C%81/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(1 min)</span>
                    <span>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
Docker v20.10.10 发布
这个版本是 Docker v20.10 的第 10 个小版本，这个版本中没有什么太特别的共性问题，但是由于 Go 1.16 中 net/http 包对 $HTTP_PROXY 行为的变化，所以当你为 Docker daemon 设置代理的时候，请确认你已经正确的设置了 $HTTP_PROXY 和 $HTTPS_PROXY 等。
此版本的其他变更，可参考其 ReleaseNote 。至于 Docker v21.x 短时间内还不会发布，不过里面确实增加了一些值得一提的特性，后续新版本快发布前再跟大家分享。
Helm v3.7 正式发布
Helm v3.7 是一个特性版本，我们一起来看看有哪些值得关注的变更吧。
对 OCI Chart 的支持相关的变更
helm chart export 已删除
helm chart list 已删除
helm chart pull 由 helm pull 代替
helm chart push 由 helm push 代替
helm chart remove 已删除
helm chart save 由 helm package 代替
另外， 如果是通过旧版本创建的 OCI chart 需要使用 Helm v3.7 进行重新打包和上传才能使用。
一些新特性
新增 helm uninstall --wait
新增 helm show crds
helm dependency list 新增 --max-col-width 用于设置列宽
helm repo add 新增 --password-stdin 用于从 stdin 输入密码
helm repo update 可以指定 repo 名称进…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.kawabangga.com">卡瓦邦噶！</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">多租户环境中的 TCP 限速（基于 iptables）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.kawabangga.com/posts/4594">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>我们有个服务以类似 SideCar 的方式和应用一起运行，SideCar 和应用通过 Unix Domain  […]
Continue reading...
The post 多租户环境中的 TCP 限速（基于 iptables） first appeared on 卡瓦邦噶！.

相关文章:

uWSGI socket 队列被占满的问题
Apache2 “AH00558: apache2: Could not reliably…
DNS 解析的原理
HTTP连接池（基于Python的requests和urllib3）
做一件事，做好它。——苹果</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>

  <footer>
    <time id="build-timestamp" datetime="2021-11-27T00:59:07.447Z">2021-11-27T00:59:07.447Z</time>
    <span><a class="footer-link" href="https://github.com/osmoscraft/osmosfeed">osmosfeed 1.11.3</a></span>
  </footer>
  <script src="index.js"></script>
  <!-- %before-body-end.html% -->
</body>

</html>