<!DOCTYPE html>
<html lang="en">

<head>
  <title>osmos::feed</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="noindex, nofollow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="osmos::feed" href="feed.atom" />
  <link href="index.css" rel="stylesheet" />
  <!-- %before-head-end.html% -->
</head>

<body>
<!-- %after-body-begin.html% -->
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-26">2021-12-26</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">K8S 生态周报| Helm 新版本发布，解决了内存泄漏的问题</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E8%A7%A3%E5%86%B3%E4%BA%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(1 min)</span>
                    <span>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
Trivy v0.22.0 正式发布
Trivy 是一款轻量级的漏洞扫描工具，支持包括容器镜像，文件系统，IaC 配置文件等。在我之前的 『K8s生态周报』文章中已经介绍过多次，此处就不再展开了。我们一起来看看这个版本中有哪些值得关注的变更。
新增了一个 --offline-scan 的选项，在对 pom.xml 和 JAR 文件进行扫描的时候，可以通过同时指定 --skip-update 和 --offline-scan 参数来避免 Trivy 去发起更新漏洞库的请求。在离线环境或者网络不好的场景下会比较有用；
优化了内存的使用，在之前版本的逻辑中，如果对于大文件也会直接进行读取，有可能会造成 OOM 。本次修正了该问题，加入了一定的缓存。如果你正在使用 Trivy ，我建议你进行更新；
再对 rpm 包扫描的时候， 支持了 NDB 格式 ， 对此格式感兴趣的小伙伴可以去看看 rpm 项目的发版说明。
你可以直接去它的 Release 页面下载最新的二进制，也可以直接使用其容器镜像。
(MoeLove) ➜ docker pull aquasec/trivy:0.22.0


对于此版本的其他变更，可参考其 ReleaseNote
Helm v3.7.2 发布
Helm 最新一个大版本是 v3.7.0，但如果你去关注这个项目实际的变更，你会发现即使是大版本更新，也没有携带特别值得有价值的内容。反倒是这个小版本中还带来了一些值得注意的内容：
修复了一个 Helm upgrade 时，内存泄漏的问题，感兴趣的小伙伴可以去围观下 https://github.com/helm/helm/issues/10439
至于之前版本中的变更，感兴趣的小伙伴可以自行去…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://yeshan333.github.io/">ShanSan</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Git 仓库瘦身与 LFS 大文件存储</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://yeshan333.github.io/2021/12/26/git-lfs-and-thin-repo/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>熟悉 Git 的小伙伴应该都知道随着 Git 仓库维护的时间越来越久，追踪的文件越来越多，git 存储的 objects 数量会极其庞大，每次从远程仓库 git clone 的时候都会墨迹很久。如果我们不小心 git add 了一个体积很大的文件，且 git push 到了远程仓库，那么我们 git clone 的时候也会很慢。
看一下 GitHub 上的 microsoft/vscode 仓库，都有 九万多个 commit 了，可想而知 objects 的数量应该很恐怖，尝试 clone 一下（一百多万个 objects）：</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-22">2021-12-22</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.codedump.info/">codedump的网络日志</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">sqlite3.36版本 btree实现（三）- journal文件备份机制</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.codedump.info/post/20211222-sqlite-btree-3-journal/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(1 min)</span>
                    <span>概述 在上一节中（sqlite3.36版本 btree实现（二）- 并发控制框架），已经讲解了sqlite中的并发控制机制，里面会涉及到一个“备份</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-21">2021-12-21</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://coolshell.cn">酷 壳 – CoolShell</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">我做系统架构的一些原则</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://coolshell.cn/articles/21672.html">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(5 min)</span>
                    <span>工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比...
 Read More  Read More
我做系统架构的一些原则 first appeared on 酷 壳 - CoolShell.</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-20">2021-12-20</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">倍受关注的 Cilium Service Mesh 到底怎么玩？ - 上手实践</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/21/%E5%80%8D%E5%8F%97%E5%85%B3%E6%B3%A8%E7%9A%84-Cilium-Service-Mesh-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%8E%A9-%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(11 min)</span>
                    <span>大家好，我是张晋涛。
Cilium 是一个基于 eBPF 技术，用于为容器工作负载间提供安全且具备可观测性的网络连接的开源软件。
如果你对 Cilium 还不太了解，可以参考我之前的两篇文章：
K8S生态周报| Google 选择 Cilium 作为 GKE 下一代数据面
Cilium 上手实践
最近 Cilium v1.11.0 正式发布了，增加 Open Telemetry 的支持以及其他一些增强特性。同时，也宣布了 Cilium Service Mesh 的计划。当前 Cilium Service Mesh 正处于测试阶段，预期在 2022 年会合并到 Cilium v1.12 版本中。
Cilium Service Mesh 也带来了一个全新的模式。
Cilium 直接通过 eBPF 技术实现的 Service Mesh 相比我们常规的 Istio/Linkerd 等方案，最显著的特点就是将 Sidecar proxy 模型替换成了 Kernel 模型， 如下图：

不再需要每个应用程序旁边都放置一个 Sidecar 了，直接在每台 Node 上提供支持。

我在几个月前就已经知道了这个消息并且进行了一些讨论，最近随着 isovalent 的一篇文章 How eBPF will solve Service Mesh - Goodbye Sidecars ，Cilium Service Mesh 也成为了大家关注的焦点。
本篇我带你实际体验下 Cilium Service Mesh。
安装部署
这里我使用 KIND 作为测试环境，我的内核版本是 5.15.8 。
准备 KIND 集群
关于 KIND 命令行工具的安装这里就不再赘述了，感兴趣的小伙伴可以参考我之前的文章 《使用KIND搭建自己的本地 Kubernetes 测试环境》。
以下是我创建集群使用的配置文件：
…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-18">2021-12-18</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">GitOps 应用实践系列 - Flux CD 及其核心组件</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/18/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-Flux-CD-%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
经过前面三篇文章，不仅为大家介绍了什么是 GitOps 也介绍了如何利用 Argo CD 来实施 GitOps。本篇我来为你介绍另一个可用于实施 GitOps 的工具：Flux CD 。
Flux CD

Flux 是一组可支持实现 GitOps 的工具，用于使 Kubernetes 集群与配置源（如 Git 仓库）保持同步，并在有代码更新后自动同步配置，面向 Kubernetes 的持续渐进式交付解决方案。

Flux CD 的发展历史
2016 年 10 月 28 日，Flux single-user service 版本发布。
它奠定了 flux 的两个基调：
集中式运行的服务
以守护进程的方式，在自动模式下运行在 k8s 集群中
2016 年 12 月 15 日，发布《使用 Weave Flux 持续交付》，构建了将 CI 与持续部署 (CD) 联系起来的 Flux。
​ 
2017 年 8 月 22 日，v1.0.0 版本正式发布。
自 v1.0.0 开始，Flux 致力于将集群与存储在 Git 中的配置同步，并在新版本准备好部署时自动升级镜像。（提出了：Configuration as code）
​ 
2018 年 5 月 1 日，发布的 alpha 版本中，集成了 Helm Operator 。这是 Flux Helm Operator 的第一个 alpha 标签的版本。
2019 年 8 月 15 日，Flux 宣布加入 CNCF Sandbox。随着各开发者及企业开始落地 GitOps ，Flux 的用户数量不断增长。 彼时已超过 2500 个 GitHub star，也在不断地集成：Helm Operator 、 Kustomize 、 Weave Flagger 、 OpenFaaS 、 Fluxcloud 、 Flux Web…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.codedump.info/">codedump的网络日志</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">sqlite3.36版本 btree实现（二）- 并发控制框架</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(1 min)</span>
                    <span>概述 按照之前起步阶段对sqlite btree整体架构的分析，“页面管理模块”分为以下几个子模块： 页面缓存管理。 崩溃恢复，又分为以下两种实现：</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-17">2021-12-17</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://www.codedump.info/">codedump的网络日志</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">sqlite3.36版本 btree实现（一）- 管理页面缓存</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>概述 页面管理模块中，很重要的一个功能是缓存页面的内容在内存中： 读页面：如果页面已经在内存，就不需要到文件中读出页面内容。 写页面：如果页面已经</span>
                  </div>
                </a>
              </details>
            </article>
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">sqlite3.36版本 btree实现（零）- 起步及概述</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://www.codedump.info/post/20211217-sqlite-btree-0/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>起步 在去年大体把btree以及b+tree算法流程研究了之后，我写了两篇博客： B树、B+树索引算法原理（上） - codedump的网络日志 B树</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-16">2021-12-16</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Grafana k6 的上手实践</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/17/Grafana-k6-%E7%9A%84%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
本篇我将为你介绍一个工具 - k6 ，它和 K8s 并没有什么直接的关系，它是一款开源的性能压测工具。
k6 背后的故事
2016 年 8 月，k6 在 GitHub 上发布了第一个版本，至此，一个出色的开源负载压测工具进入了人们的视野。
2021 年的 6 月，对于 Grafana 和 k6 来讲是个大日子，Grafana Labs 收购了 k6 。
而事实上， Grafana 与 k6 的缘分还要追溯到更早的 2 年前。
2019 年，在进行 Grafana 6.0 的短期令牌刷新行为的压测时，Grafana Labs 进行了一系列的技术选型。
由于 Grafana Labs 的大部分后端软件是使用 Go 来实现的，恰巧 k6 满足 OSS 和 Go 需求，并且负载测试是使用 JS 编写（Grafana 前端框架及 UI 都在使用）。这使得 k6 自 Grafana 6.0 版本开始，不断地为 Grafana 开发者及测试者完成追踪 bug 的使命。

图 1 ，k6 加入 Grafana Labs
多样的压测工具
一个称心应手的自动化负载压测工具会极大的提升程序开发人员的代码质量及效率。
下图中是一些比较常见的用于负载压测的工具，我们可以在 GitHub 上看到，目前，更新比较频繁、活跃的项目主要有：Gatling, Jmeter 和 k6 。

图 2 ，压测工具们
如何从中选择，简单的讲就是工具效率的比拼。主要从以下两个方面来考量：
工具性能
工具使用体验
下图对以上工具进行了一些简单的对比。

这里我主要对比下其中较为活跃的 3 个项目。
JMeter - 熟悉 Java 的小伙伴可能比较了解这个工具。由于存在时间久，JMeter 的功能是这之中最全面的，并且集成、附加组件做的较好。基于它构建的 SaaS 服务 Blazemeter，相信大…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-12">2021-12-12</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">搞懂容器技术的基石： namespace （下）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/13/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8B/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。
对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。
我们先对这两项技术的作用做个概括：
cgroup 的主要作用：管理资源的分配、限制；
namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；
这是一个系列文章，对此系列感兴趣的小伙伴可以查看：
彻底搞懂容器技术的基石：cgroup
彻底搞懂容器技术的基石：namespace（上）
本篇我们将继续聊 namespace。
Namespace 类型
我们先来总览一下 namespace 的类型，上篇中已经为大家介绍过 Cgroup , IPC, Network 和 Mount 等 4 种类型的 namespace。我们继续聊剩余的部分。
namespace名称
使用的标识 - Flag
控制内容




Cgroup
CLONE_NEWCGROUP
Cgroup root directory cgroup 根目录


IPC
CLONE_NEWIPC
System V IPC, POSIX message queues信号量，消息队列


Network
CLONE_NEWNET
Network devices, stacks, ports, etc.网络设备，协议栈，端口等等


Mount
CLONE_NEWNS
Mount points挂载点


PID
CLONE_NEWPID
Process IDs进程号


Time
CLONE_NEWTIME
Boot and monotonic clocks启动和单调时钟


User
CLONE_NEWUSER
User and …</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-09">2021-12-09</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">搞懂容器技术的基石： namespace （上）</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。
对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。
我们先对这两项技术的作用做个概括：
cgroup 的主要作用：管理资源的分配、限制；
namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；
在上一篇文章中，我们重点聊了 cgroup 。本篇，我们重点来聊 namespace 。
Namespace 是什么？
我们引用 wiki 上对 namespace 的定义：
Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.
namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。
这样的说法未免太绕了些，简单来说 name…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-07">2021-12-07</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.23.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
Kubernetes v1.23 即将发布，这是 2021 年发布的第三个版本，也是今年最后一个正式发布的版本。
此版本中主要包括 47 项增强更新，其中 11 项达到 stable, 17 项达到 beta 还有 19 项达到 alpha 。 当然，也有 1 项被标记为废弃。相比于 v1.22 从数量上来说是少了一点（v1.22 有 53 项增强更新），但这并不影响这是一个很棒的版本！
在 Kubernetes 的发布周期变更为 每4个月一个版本 后，很明显的感觉就是不用在升级上面花费太多时间了，毕竟 Kubernetes 的升级操作是个体力活，大家觉得呢？
我们一起来看看这个版本中有哪些值得关注的变更吧！
新增 kubectl alpha events 命令
在之前的 《K8S 生态周报| Helm 新版本发布增强对 OCI 的支持》 文章的上游进展中我曾为大家介绍了该功能。它是按照 KEP #1440 实施的。
增加此命令主要是由于在不修改 kubectl get 的前提下，查看 event 有一些限制，所以直接增加 kubectl events 命令可以更方便的去获取到需要的信息，尤其是 event 是在 Kubernetes 中经常需要查看的一个信息。kubectl get events 比较典型的一些问题, 比如排序（虽然可以通过加参数解决）， watch，以及无法按照时间线方式去查看 events 等。
我们来看看这个命令具体如何使用。
我们先来创建两个 Pod，分别叫 redis 和 redis2 。
(MoeLove) ➜ kubectl run redis --image&#x3D;&quot;ghcr.io/tao12345666333/redis:a…</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-06">2021-12-06</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Open Policy Agent (OPA) 入门实践</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/12/06/Open-Policy-Agent-OPA-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(2 min)</span>
                    <span>大家好，我是张晋涛。
本篇我来为你介绍一个我个人很喜欢的，通用策略引擎，名叫 OPA，全称是 Open Policy Agent。
在具体聊 OPA 之前，我们先来聊一下为什么需要一个通用策略引擎，以及 OPA 解决了什么问题。
OPA 解决了什么问题
在实际的生产环境中很多场景中都需要策略控制，比如：
需要策略控制用户是否可登陆服务器或者做一些操作；
需要策略控制哪些项目/哪些组件可进行部署；
需要策略控制如何访问数据库；
需要策略控制哪些资源可部署到 Kubernetes 中；

但是对于这些场景或者软件来说，配置它们的策略是需要与该软件进行耦合的，彼此是不统一，不通用的。管理起来也会比较混乱，带来了不小的维护成本。
OPA 的出现可以将各处配置的策略进行统一，极大的降低了维护成本。以及将策略与对应的软件/服务进行解耦，方便进行移植/复用。

OPA 的发展过程
OPA 最初是由 Styra 公司在 2016 年创建并开源的项目，目前该公司的主要产品就是提供可视化策略控制及策略执行的可视化 Dashboard 服务的。
OPA 首次进入 CNCF 并成为 sandbox 级别的项目是在 2018 年， 在 2021 年的 2 月份便已经从 CNCF 毕业，这个过程相对来说还是比较快的，由此也可以看出 OPA 是一个比较活跃且应用广泛的项目。
OPA 是什么
前面我们已经介绍过 Open Policy Agent (OPA) 是一种开源的通用策略引擎，可在整个堆栈中实现统一、上下文感知的策略控制。
OPA 可将策略决策与应用程序的业务逻辑分离（解耦），透过现象看本质，策略就是一组规则，请求发送到引擎，引擎根据规则来进行决策。

图 3 ，OPA 的策略解耦示例
OPA 并不负责具体任务的执行，它仅负责决策，需要决策的请求通过 JSON 的方式传递给 OPA ，在 OPA …</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-12-04">2021-12-04</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://yeshan333.github.io/">ShanSan</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">Deserve</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://yeshan333.github.io/2021/12/04/deserve/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(0 min)</span>
                    <span>今天凌晨五点就醒了，积累了好多好多的情绪啊！</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>
  <section class="daily-content">
    <h2 class="daily-heading"><time datatime="2021-11-29">2021-11-29</time></h2>
    <ul class="sources card">
      <li class="source">
        <section>
          <h3 class="source-name"><a class="source-name__link" href="https://moelove.info/">MoeLove</a></h3>
          <section class="articles-per-source">
            <article>
              <details class="article-expander">
                <summary class="article-expander__title">理清 Kubernetes 中的准入控制（Admission Controller)</summary>
                <a class="article-summary-link article-summary-box-outer" href="https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/">
                  <div class="article-summary-box-inner">
                    <span class="article-reading-time">(3 min)</span>
                    <span>大家好，我是张晋涛。
在我之前发布的文章 《云原生时代下的容器镜像安全》（系列）中，我提到过 Kubernetes 集群的核心组件 -- kube-apiserver，它允许来自终端用户或集群的各组件与之进行通信（例如，查询、创建、修改或删除 Kubernetes 资源）。
本篇我们将聚焦于 kube-apiserver 请求处理过程中一个很重要的部分 -- 准入控制器（Admission Controller）
K8s 的准入控制器是什么
K8s 中的请求处理流程
在聊 K8s 准入控制器是什么之前，让我们先来回顾一下 Kubernetes API 的处理具体请求的过程。

图 1 ，Kubernetes API 处理请求的过程 （从 API Handler 到 etcd 持久化的过程）
如上图所示，每个 API 的请求从开始被 kube-apiserver 接收到最终持久化到 ETCD 的过程，即为 Kubernetes API 的请求处理流程。
它主要包含了以下几个部分：
API Handler -- 主要负责提供服务，接收请求。
对于其内部实现而言，请求会先到 FullHandlerChain （它是由 DefaultBuildHandlerChain 构建出来的）是一个 director 对象
type director struct {
name string
goRestfulContainer *restful.Container
nonGoRestfulMux *mux.PathRecorderMux
}


director根据配置进行初始化，如果 goRestfulContainer的 WebServices 的 RootPath 是 /apis，或者请求前缀与 RootPath 匹配，则进入 Restful 处理链路。
Authentication …</span>
                  </div>
                </a>
              </details>
            </article>
        </section>
      </li>
    </ul>
  </section>

  <footer>
    <time id="build-timestamp" datetime="2021-12-28T01:04:51.545Z">2021-12-28T01:04:51.545Z</time>
    <span><a class="footer-link" href="https://github.com/osmoscraft/osmosfeed">osmosfeed 1.11.3</a></span>
  </footer>
  <script src="index.js"></script>
  <!-- %before-body-end.html% -->
</body>

</html>